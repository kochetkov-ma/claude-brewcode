# Large Codebase Simulation File
# This file simulates a large codebase for context overflow testing
# Generated for focus-task plugin testing

================================================================================
## MODULE 1: Authentication Service
================================================================================

```java
package com.example.auth.service;

import org.springframework.stereotype.Service;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class AuthenticationService {

    private final UserRepository userRepository;
    private final TokenService tokenService;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AuditLogService auditLogService;

    public AuthResponse authenticate(AuthRequest request) {
        log.info("Authentication attempt for user: {}", request.getUsername());
        
        User user = userRepository.findByUsername(request.getUsername())
            .orElseThrow(() -> new AuthenticationException("User not found"));
        
        if (!passwordEncoder.matches(request.getPassword(), user.getPasswordHash())) {
            auditLogService.logFailedLogin(user.getId(), request.getIpAddress());
            throw new AuthenticationException("Invalid credentials");
        }
        
        if (!user.isEnabled()) {
            throw new AuthenticationException("Account disabled");
        }
        
        String accessToken = tokenService.generateAccessToken(user);
        String refreshToken = tokenService.generateRefreshToken(user);
        
        auditLogService.logSuccessfulLogin(user.getId(), request.getIpAddress());
        
        return AuthResponse.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .expiresIn(tokenService.getAccessTokenExpiration())
            .tokenType("Bearer")
            .build();
    }

    public AuthResponse refreshToken(String refreshToken) {
        TokenClaims claims = tokenService.validateRefreshToken(refreshToken);
        
        User user = userRepository.findById(claims.getUserId())
            .orElseThrow(() -> new AuthenticationException("User not found"));
        
        String newAccessToken = tokenService.generateAccessToken(user);
        
        return AuthResponse.builder()
            .accessToken(newAccessToken)
            .refreshToken(refreshToken)
            .expiresIn(tokenService.getAccessTokenExpiration())
            .tokenType("Bearer")
            .build();
    }

    public void logout(String accessToken) {
        tokenService.revokeToken(accessToken);
        log.info("User logged out successfully");
    }

    public void changePassword(Long userId, ChangePasswordRequest request) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException(userId));
        
        if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPasswordHash())) {
            throw new AuthenticationException("Current password is incorrect");
        }
        
        validatePasswordStrength(request.getNewPassword());
        
        user.setPasswordHash(passwordEncoder.encode(request.getNewPassword()));
        user.setPasswordChangedAt(Instant.now());
        userRepository.save(user);
        
        tokenService.revokeAllUserTokens(userId);
        auditLogService.logPasswordChange(userId);
    }

    private void validatePasswordStrength(String password) {
        if (password.length() < 12) {
            throw new ValidationException("Password must be at least 12 characters");
        }
        if (!password.matches(".*[A-Z].*")) {
            throw new ValidationException("Password must contain uppercase letter");
        }
        if (!password.matches(".*[a-z].*")) {
            throw new ValidationException("Password must contain lowercase letter");
        }
        if (!password.matches(".*\\d.*")) {
            throw new ValidationException("Password must contain digit");
        }
        if (!password.matches(".*[!@#$%^&*()].*")) {
            throw new ValidationException("Password must contain special character");
        }
    }
}
```

================================================================================
## MODULE 2: Order Processing Service
================================================================================

```java
package com.example.orders.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class OrderProcessingService {

    private final OrderRepository orderRepository;
    private final ProductService productService;
    private final InventoryService inventoryService;
    private final PaymentService paymentService;
    private final NotificationService notificationService;
    private final ShippingService shippingService;
    private final TaxCalculationService taxService;
    private final DiscountService discountService;

    @Transactional
    public OrderResponse createOrder(CreateOrderRequest request) {
        log.info("Creating order for customer: {}", request.getCustomerId());
        
        // Validate products availability
        List<OrderItem> items = request.getItems().stream()
            .map(this::validateAndCreateOrderItem)
            .collect(Collectors.toList());
        
        // Calculate totals
        BigDecimal subtotal = calculateSubtotal(items);
        BigDecimal discount = discountService.calculateDiscount(request.getPromoCode(), subtotal);
        BigDecimal tax = taxService.calculateTax(subtotal.subtract(discount), request.getShippingAddress());
        BigDecimal shippingCost = shippingService.calculateShippingCost(items, request.getShippingAddress());
        BigDecimal total = subtotal.subtract(discount).add(tax).add(shippingCost);
        
        // Create order
        Order order = Order.builder()
            .customerId(request.getCustomerId())
            .items(items)
            .subtotal(subtotal)
            .discount(discount)
            .tax(tax)
            .shippingCost(shippingCost)
            .total(total)
            .status(OrderStatus.PENDING)
            .shippingAddress(request.getShippingAddress())
            .billingAddress(request.getBillingAddress())
            .createdAt(Instant.now())
            .build();
        
        order = orderRepository.save(order);
        
        // Reserve inventory
        items.forEach(item -> inventoryService.reserveStock(item.getProductId(), item.getQuantity()));
        
        log.info("Order {} created successfully with total: {}", order.getId(), total);
        
        return mapToResponse(order);
    }

    @Transactional
    public OrderResponse processPayment(Long orderId, PaymentRequest paymentRequest) {
        Order order = getOrderOrThrow(orderId);
        
        if (order.getStatus() != OrderStatus.PENDING) {
            throw new OrderProcessingException("Order is not in pending status");
        }
        
        PaymentResult result = paymentService.processPayment(
            paymentRequest.getPaymentMethodId(),
            order.getTotal(),
            order.getId().toString()
        );
        
        if (result.isSuccessful()) {
            order.setStatus(OrderStatus.PAID);
            order.setPaymentId(result.getTransactionId());
            order.setPaidAt(Instant.now());
            
            // Commit inventory reservation
            order.getItems().forEach(item -> 
                inventoryService.commitReservation(item.getProductId(), item.getQuantity()));
            
            // Trigger fulfillment
            shippingService.createShipment(order);
            
            // Send confirmation
            notificationService.sendOrderConfirmation(order);
            
            log.info("Payment processed successfully for order: {}", orderId);
        } else {
            order.setStatus(OrderStatus.PAYMENT_FAILED);
            order.setPaymentError(result.getErrorMessage());
            
            // Release inventory reservation
            order.getItems().forEach(item -> 
                inventoryService.releaseReservation(item.getProductId(), item.getQuantity()));
            
            log.warn("Payment failed for order: {} - {}", orderId, result.getErrorMessage());
        }
        
        orderRepository.save(order);
        return mapToResponse(order);
    }

    @Transactional
    public OrderResponse cancelOrder(Long orderId, String reason) {
        Order order = getOrderOrThrow(orderId);
        
        if (!order.getStatus().isCancellable()) {
            throw new OrderProcessingException("Order cannot be cancelled in current status");
        }
        
        // Refund if already paid
        if (order.getPaymentId() != null) {
            paymentService.refund(order.getPaymentId(), order.getTotal());
        }
        
        // Release inventory
        order.getItems().forEach(item -> 
            inventoryService.releaseStock(item.getProductId(), item.getQuantity()));
        
        order.setStatus(OrderStatus.CANCELLED);
        order.setCancellationReason(reason);
        order.setCancelledAt(Instant.now());
        
        orderRepository.save(order);
        
        notificationService.sendOrderCancellation(order);
        
        log.info("Order {} cancelled: {}", orderId, reason);
        
        return mapToResponse(order);
    }

    public List<OrderResponse> getCustomerOrders(Long customerId, Pageable pageable) {
        return orderRepository.findByCustomerId(customerId, pageable)
            .stream()
            .map(this::mapToResponse)
            .collect(Collectors.toList());
    }

    public OrderResponse getOrderDetails(Long orderId) {
        return mapToResponse(getOrderOrThrow(orderId));
    }

    private OrderItem validateAndCreateOrderItem(OrderItemRequest request) {
        Product product = productService.getProduct(request.getProductId());
        
        if (!product.isAvailable()) {
            throw new ProductNotAvailableException(product.getId());
        }
        
        if (!inventoryService.hasStock(product.getId(), request.getQuantity())) {
            throw new InsufficientStockException(product.getId(), request.getQuantity());
        }
        
        return OrderItem.builder()
            .productId(product.getId())
            .productName(product.getName())
            .quantity(request.getQuantity())
            .unitPrice(product.getPrice())
            .totalPrice(product.getPrice().multiply(BigDecimal.valueOf(request.getQuantity())))
            .build();
    }

    private BigDecimal calculateSubtotal(List<OrderItem> items) {
        return items.stream()
            .map(OrderItem::getTotalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    private Order getOrderOrThrow(Long orderId) {
        return orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
    }

    private OrderResponse mapToResponse(Order order) {
        return OrderResponse.builder()
            .id(order.getId())
            .customerId(order.getCustomerId())
            .items(order.getItems().stream()
                .map(this::mapItemToResponse)
                .collect(Collectors.toList()))
            .subtotal(order.getSubtotal())
            .discount(order.getDiscount())
            .tax(order.getTax())
            .shippingCost(order.getShippingCost())
            .total(order.getTotal())
            .status(order.getStatus())
            .createdAt(order.getCreatedAt())
            .build();
    }

    private OrderItemResponse mapItemToResponse(OrderItem item) {
        return OrderItemResponse.builder()
            .productId(item.getProductId())
            .productName(item.getProductName())
            .quantity(item.getQuantity())
            .unitPrice(item.getUnitPrice())
            .totalPrice(item.getTotalPrice())
            .build();
    }
}
```

================================================================================
## MODULE 3: Inventory Management System
================================================================================

```java
package com.example.inventory.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
@Slf4j
@RequiredArgsConstructor
public class InventoryManagementService {

    private final InventoryRepository inventoryRepository;
    private final WarehouseRepository warehouseRepository;
    private final ReorderService reorderService;
    private final NotificationService notificationService;
    private final AuditService auditService;
    
    private final Map<String, ReservationLock> reservationLocks = new ConcurrentHashMap<>();

    @Transactional
    public InventoryItem addStock(Long productId, Long warehouseId, int quantity, String reason) {
        log.info("Adding {} units of product {} to warehouse {}", quantity, productId, warehouseId);
        
        InventoryItem item = getOrCreateInventoryItem(productId, warehouseId);
        int previousQuantity = item.getQuantityOnHand();
        
        item.setQuantityOnHand(item.getQuantityOnHand() + quantity);
        item.setLastRestockedAt(Instant.now());
        
        inventoryRepository.save(item);
        
        auditService.logInventoryChange(
            productId, warehouseId, previousQuantity, item.getQuantityOnHand(), reason
        );
        
        checkReorderThreshold(item);
        
        return item;
    }

    @Transactional
    public synchronized boolean reserveStock(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdOrderByQuantityDesc(productId);
        
        int totalAvailable = items.stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        if (totalAvailable < quantity) {
            log.warn("Insufficient stock for product {}: requested {}, available {}", 
                productId, quantity, totalAvailable);
            return false;
        }
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int available = item.getQuantityOnHand() - item.getQuantityReserved();
            int toReserve = Math.min(available, remaining);
            
            if (toReserve > 0) {
                item.setQuantityReserved(item.getQuantityReserved() + toReserve);
                inventoryRepository.save(item);
                remaining -= toReserve;
                
                log.debug("Reserved {} units from warehouse {} for product {}", 
                    toReserve, item.getWarehouseId(), productId);
            }
        }
        
        return true;
    }

    @Transactional
    public void commitReservation(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdAndQuantityReservedGreaterThan(productId, 0);
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int toCommit = Math.min(item.getQuantityReserved(), remaining);
            
            item.setQuantityOnHand(item.getQuantityOnHand() - toCommit);
            item.setQuantityReserved(item.getQuantityReserved() - toCommit);
            inventoryRepository.save(item);
            
            remaining -= toCommit;
            
            checkReorderThreshold(item);
        }
        
        log.info("Committed reservation of {} units for product {}", quantity, productId);
    }

    @Transactional
    public void releaseReservation(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdAndQuantityReservedGreaterThan(productId, 0);
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int toRelease = Math.min(item.getQuantityReserved(), remaining);
            item.setQuantityReserved(item.getQuantityReserved() - toRelease);
            inventoryRepository.save(item);
            
            remaining -= toRelease;
        }
        
        log.info("Released reservation of {} units for product {}", quantity, productId);
    }

    public boolean hasStock(Long productId, int quantity) {
        int available = inventoryRepository.findByProductId(productId).stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        return available >= quantity;
    }

    public InventoryStatus getInventoryStatus(Long productId) {
        List<InventoryItem> items = inventoryRepository.findByProductId(productId);
        
        int totalOnHand = items.stream().mapToInt(InventoryItem::getQuantityOnHand).sum();
        int totalReserved = items.stream().mapToInt(InventoryItem::getQuantityReserved).sum();
        int totalAvailable = totalOnHand - totalReserved;
        
        return InventoryStatus.builder()
            .productId(productId)
            .totalOnHand(totalOnHand)
            .totalReserved(totalReserved)
            .totalAvailable(totalAvailable)
            .warehouseBreakdown(items.stream()
                .collect(Collectors.toMap(
                    InventoryItem::getWarehouseId,
                    i -> new WarehouseStock(i.getQuantityOnHand(), i.getQuantityReserved())
                )))
            .build();
    }

    @Scheduled(cron = "0 0 * * * *")
    public void checkLowStockLevels() {
        log.info("Running scheduled low stock check");
        
        List<InventoryItem> lowStockItems = inventoryRepository.findItemsBelowReorderPoint();
        
        for (InventoryItem item : lowStockItems) {
            if (!reorderService.hasPendingReorder(item.getProductId())) {
                ReorderRequest request = calculateReorderQuantity(item);
                reorderService.createReorderRequest(request);
                
                notificationService.sendLowStockAlert(item);
                
                log.info("Created reorder request for product {} at warehouse {}", 
                    item.getProductId(), item.getWarehouseId());
            }
        }
    }

    @Transactional
    public void transferStock(Long productId, Long fromWarehouse, Long toWarehouse, int quantity) {
        InventoryItem source = inventoryRepository.findByProductIdAndWarehouseId(productId, fromWarehouse)
            .orElseThrow(() -> new InventoryNotFoundException(productId, fromWarehouse));
        
        int available = source.getQuantityOnHand() - source.getQuantityReserved();
        if (available < quantity) {
            throw new InsufficientStockException(productId, quantity);
        }
        
        source.setQuantityOnHand(source.getQuantityOnHand() - quantity);
        inventoryRepository.save(source);
        
        InventoryItem destination = getOrCreateInventoryItem(productId, toWarehouse);
        destination.setQuantityOnHand(destination.getQuantityOnHand() + quantity);
        inventoryRepository.save(destination);
        
        auditService.logStockTransfer(productId, fromWarehouse, toWarehouse, quantity);
        
        log.info("Transferred {} units of product {} from warehouse {} to {}", 
            quantity, productId, fromWarehouse, toWarehouse);
    }

    private InventoryItem getOrCreateInventoryItem(Long productId, Long warehouseId) {
        return inventoryRepository.findByProductIdAndWarehouseId(productId, warehouseId)
            .orElseGet(() -> {
                Warehouse warehouse = warehouseRepository.findById(warehouseId)
                    .orElseThrow(() -> new WarehouseNotFoundException(warehouseId));
                
                return InventoryItem.builder()
                    .productId(productId)
                    .warehouseId(warehouseId)
                    .quantityOnHand(0)
                    .quantityReserved(0)
                    .reorderPoint(warehouse.getDefaultReorderPoint())
                    .reorderQuantity(warehouse.getDefaultReorderQuantity())
                    .build();
            });
    }

    private void checkReorderThreshold(InventoryItem item) {
        int available = item.getQuantityOnHand() - item.getQuantityReserved();
        
        if (available <= item.getReorderPoint()) {
            log.info("Product {} at warehouse {} below reorder point: {} <= {}", 
                item.getProductId(), item.getWarehouseId(), available, item.getReorderPoint());
            
            if (!reorderService.hasPendingReorder(item.getProductId())) {
                ReorderRequest request = calculateReorderQuantity(item);
                reorderService.createReorderRequest(request);
            }
        }
    }

    private ReorderRequest calculateReorderQuantity(InventoryItem item) {
        // Calculate based on historical demand and lead time
        int suggestedQuantity = Math.max(
            item.getReorderQuantity(),
            (int) (demandForecastService.getAverageDailyDemand(item.getProductId()) * 
                   supplierService.getLeadTimeDays(item.getProductId()) * 1.5)
        );
        
        return ReorderRequest.builder()
            .productId(item.getProductId())
            .warehouseId(item.getWarehouseId())
            .quantity(suggestedQuantity)
            .priority(available <= item.getReorderPoint() / 2 ? Priority.HIGH : Priority.NORMAL)
            .build();
    }
}
```

================================================================================
## MODULE 4: Payment Processing Gateway
================================================================================

```java
package com.example.payment.service;

import org.springframework.stereotype.Service;
import org.springframework.retry.annotation.Retryable;
import org.springframework.retry.annotation.Backoff;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.math.BigDecimal;
import java.util.UUID;

@Service
@Slf4j
@RequiredArgsConstructor
public class PaymentGatewayService {

    private final StripeClient stripeClient;
    private final PayPalClient payPalClient;
    private final PaymentRepository paymentRepository;
    private final FraudDetectionService fraudDetectionService;
    private final CurrencyConversionService currencyService;
    private final PaymentEventPublisher eventPublisher;

    @Retryable(
        value = {PaymentGatewayException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public PaymentResult processPayment(PaymentRequest request) {
        log.info("Processing payment of {} {} for order {}", 
            request.getAmount(), request.getCurrency(), request.getOrderId());
        
        // Fraud check
        FraudCheckResult fraudResult = fraudDetectionService.checkTransaction(request);
        if (fraudResult.isBlocked()) {
            log.warn("Payment blocked by fraud detection: {}", fraudResult.getReason());
            return PaymentResult.failed(fraudResult.getReason());
        }
        
        // Create payment record
        Payment payment = Payment.builder()
            .id(UUID.randomUUID().toString())
            .orderId(request.getOrderId())
            .amount(request.getAmount())
            .currency(request.getCurrency())
            .paymentMethodId(request.getPaymentMethodId())
            .status(PaymentStatus.PROCESSING)
            .createdAt(Instant.now())
            .build();
        
        paymentRepository.save(payment);
        
        try {
            PaymentResult result = processWithGateway(request, payment);
            
            if (result.isSuccessful()) {
                payment.setStatus(PaymentStatus.COMPLETED);
                payment.setGatewayTransactionId(result.getTransactionId());
                payment.setCompletedAt(Instant.now());
                
                eventPublisher.publishPaymentCompleted(payment);
            } else {
                payment.setStatus(PaymentStatus.FAILED);
                payment.setErrorMessage(result.getErrorMessage());
                
                eventPublisher.publishPaymentFailed(payment);
            }
            
            paymentRepository.save(payment);
            return result;
            
        } catch (Exception e) {
            log.error("Payment processing error for order {}: {}", request.getOrderId(), e.getMessage());
            
            payment.setStatus(PaymentStatus.ERROR);
            payment.setErrorMessage(e.getMessage());
            paymentRepository.save(payment);
            
            throw new PaymentProcessingException("Payment processing failed", e);
        }
    }

    @Retryable(
        value = {RefundException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 2000, multiplier = 2)
    )
    public RefundResult refund(String paymentId, BigDecimal amount, String reason) {
        Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow(() -> new PaymentNotFoundException(paymentId));
        
        if (payment.getStatus() != PaymentStatus.COMPLETED) {
            throw new RefundException("Cannot refund payment in status: " + payment.getStatus());
        }
        
        BigDecimal refundedAmount = payment.getRefunds().stream()
            .map(Refund::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal maxRefundable = payment.getAmount().subtract(refundedAmount);
        if (amount.compareTo(maxRefundable) > 0) {
            throw new RefundException("Refund amount exceeds available: " + maxRefundable);
        }
        
        log.info("Processing refund of {} for payment {}", amount, paymentId);
        
        RefundResult result = switch (payment.getGateway()) {
            case STRIPE -> stripeClient.refund(payment.getGatewayTransactionId(), amount);
            case PAYPAL -> payPalClient.refund(payment.getGatewayTransactionId(), amount);
            default -> throw new UnsupportedGatewayException(payment.getGateway());
        };
        
        if (result.isSuccessful()) {
            Refund refund = Refund.builder()
                .id(UUID.randomUUID().toString())
                .paymentId(paymentId)
                .amount(amount)
                .reason(reason)
                .gatewayRefundId(result.getRefundId())
                .createdAt(Instant.now())
                .build();
            
            payment.getRefunds().add(refund);
            
            if (payment.getAmount().equals(refundedAmount.add(amount))) {
                payment.setStatus(PaymentStatus.FULLY_REFUNDED);
            } else {
                payment.setStatus(PaymentStatus.PARTIALLY_REFUNDED);
            }
            
            paymentRepository.save(payment);
            eventPublisher.publishRefundCompleted(refund);
        }
        
        return result;
    }

    public PaymentStatus getPaymentStatus(String paymentId) {
        return paymentRepository.findById(paymentId)
            .map(Payment::getStatus)
            .orElseThrow(() -> new PaymentNotFoundException(paymentId));
    }

    public List<Payment> getPaymentHistory(String orderId) {
        return paymentRepository.findByOrderId(orderId);
    }

    private PaymentResult processWithGateway(PaymentRequest request, Payment payment) {
        PaymentMethod method = paymentMethodRepository.findById(request.getPaymentMethodId())
            .orElseThrow(() -> new PaymentMethodNotFoundException(request.getPaymentMethodId()));
        
        // Currency conversion if needed
        BigDecimal processAmount = request.getAmount();
        String processCurrency = request.getCurrency();
        
        if (!method.getSupportedCurrencies().contains(request.getCurrency())) {
            CurrencyConversion conversion = currencyService.convert(
                request.getAmount(), 
                request.getCurrency(), 
                method.getDefaultCurrency()
            );
            processAmount = conversion.getConvertedAmount();
            processCurrency = conversion.getTargetCurrency();
            payment.setConversionRate(conversion.getRate());
        }
        
        PaymentGateway gateway = method.getGateway();
        payment.setGateway(gateway);
        
        return switch (gateway) {
            case STRIPE -> stripeClient.charge(
                method.getGatewayToken(),
                processAmount,
                processCurrency,
                payment.getId()
            );
            case PAYPAL -> payPalClient.charge(
                method.getGatewayToken(),
                processAmount,
                processCurrency,
                payment.getId()
            );
            default -> throw new UnsupportedGatewayException(gateway);
        };
    }

    @Scheduled(fixedRate = 60000)
    public void reconcilePendingPayments() {
        List<Payment> pendingPayments = paymentRepository.findByStatusAndCreatedAtBefore(
            PaymentStatus.PROCESSING,
            Instant.now().minus(Duration.ofMinutes(15))
        );
        
        for (Payment payment : pendingPayments) {
            try {
                PaymentStatus gatewayStatus = queryGatewayStatus(payment);
                
                if (gatewayStatus != payment.getStatus()) {
                    log.info("Reconciling payment {}: {} -> {}", 
                        payment.getId(), payment.getStatus(), gatewayStatus);
                    
                    payment.setStatus(gatewayStatus);
                    paymentRepository.save(payment);
                    
                    if (gatewayStatus == PaymentStatus.COMPLETED) {
                        eventPublisher.publishPaymentCompleted(payment);
                    } else if (gatewayStatus == PaymentStatus.FAILED) {
                        eventPublisher.publishPaymentFailed(payment);
                    }
                }
            } catch (Exception e) {
                log.error("Error reconciling payment {}: {}", payment.getId(), e.getMessage());
            }
        }
    }

    private PaymentStatus queryGatewayStatus(Payment payment) {
        return switch (payment.getGateway()) {
            case STRIPE -> stripeClient.getStatus(payment.getGatewayTransactionId());
            case PAYPAL -> payPalClient.getStatus(payment.getGatewayTransactionId());
            default -> payment.getStatus();
        };
    }
}
```

================================================================================
## MODULE 5: Notification Service
================================================================================

```java
package com.example.notification.service;

import org.springframework.stereotype.Service;
import org.springframework.scheduling.annotation.Async;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class NotificationService {

    private final EmailService emailService;
    private final SmsService smsService;
    private final PushNotificationService pushService;
    private final NotificationTemplateService templateService;
    private final UserPreferenceService preferenceService;
    private final NotificationRepository notificationRepository;

    @Async
    public void sendOrderConfirmation(Order order) {
        User user = userService.getUser(order.getCustomerId());
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        
        NotificationTemplate template = templateService.getTemplate("ORDER_CONFIRMATION");
        Map<String, Object> variables = buildOrderVariables(order);
        
        List<NotificationChannel> channels = determineChannels(prefs, NotificationType.ORDER_UPDATE);
        
        for (NotificationChannel channel : channels) {
            try {
                sendViaChannel(channel, user, template, variables);
                
                logNotification(user.getId(), NotificationType.ORDER_UPDATE, channel, "SUCCESS");
            } catch (Exception e) {
                log.error("Failed to send {} notification to user {}: {}", 
                    channel, user.getId(), e.getMessage());
                logNotification(user.getId(), NotificationType.ORDER_UPDATE, channel, "FAILED");
            }
        }
    }

    @Async
    public void sendOrderCancellation(Order order) {
        User user = userService.getUser(order.getCustomerId());
        NotificationTemplate template = templateService.getTemplate("ORDER_CANCELLED");
        
        Map<String, Object> variables = Map.of(
            "orderId", order.getId(),
            "reason", order.getCancellationReason(),
            "refundAmount", order.getTotal()
        );
        
        sendToAllChannels(user, template, variables, NotificationType.ORDER_UPDATE);
    }

    @Async
    public void sendShippingUpdate(Shipment shipment) {
        Order order = orderService.getOrder(shipment.getOrderId());
        User user = userService.getUser(order.getCustomerId());
        
        String templateName = switch (shipment.getStatus()) {
            case SHIPPED -> "ORDER_SHIPPED";
            case OUT_FOR_DELIVERY -> "ORDER_OUT_FOR_DELIVERY";
            case DELIVERED -> "ORDER_DELIVERED";
            default -> null;
        };
        
        if (templateName == null) return;
        
        NotificationTemplate template = templateService.getTemplate(templateName);
        Map<String, Object> variables = Map.of(
            "orderId", order.getId(),
            "trackingNumber", shipment.getTrackingNumber(),
            "carrier", shipment.getCarrier(),
            "estimatedDelivery", shipment.getEstimatedDeliveryDate()
        );
        
        sendToAllChannels(user, template, variables, NotificationType.SHIPPING_UPDATE);
    }

    @Async
    public void sendLowStockAlert(InventoryItem item) {
        List<User> admins = userService.getUsersByRole(Role.INVENTORY_MANAGER);
        NotificationTemplate template = templateService.getTemplate("LOW_STOCK_ALERT");
        
        Map<String, Object> variables = Map.of(
            "productId", item.getProductId(),
            "productName", productService.getProduct(item.getProductId()).getName(),
            "currentStock", item.getQuantityOnHand(),
            "reorderPoint", item.getReorderPoint(),
            "warehouseId", item.getWarehouseId()
        );
        
        for (User admin : admins) {
            sendViaChannel(NotificationChannel.EMAIL, admin, template, variables);
        }
    }

    @Async
    public void sendPasswordResetEmail(User user, String resetToken) {
        NotificationTemplate template = templateService.getTemplate("PASSWORD_RESET");
        
        Map<String, Object> variables = Map.of(
            "userName", user.getName(),
            "resetLink", buildResetLink(resetToken),
            "expiresIn", "24 hours"
        );
        
        emailService.send(
            user.getEmail(),
            template.getSubject(),
            template.renderBody(variables)
        );
        
        logNotification(user.getId(), NotificationType.SECURITY, NotificationChannel.EMAIL, "SUCCESS");
    }

    @Async
    public void sendTwoFactorCode(User user, String code) {
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        
        String message = String.format("Your verification code is: %s. Valid for 10 minutes.", code);
        
        if (prefs.getTwoFactorChannel() == NotificationChannel.SMS) {
            smsService.send(user.getPhoneNumber(), message);
        } else {
            emailService.send(user.getEmail(), "Verification Code", message);
        }
    }

    @Scheduled(cron = "0 0 9 * * *")
    public void sendDailyDigest() {
        List<User> users = userService.getUsersWithDigestEnabled();
        
        for (User user : users) {
            try {
                DigestContent content = buildDigestContent(user);
                
                if (content.hasItems()) {
                    NotificationTemplate template = templateService.getTemplate("DAILY_DIGEST");
                    emailService.send(
                        user.getEmail(),
                        template.getSubject(),
                        template.renderBody(Map.of("digest", content))
                    );
                }
            } catch (Exception e) {
                log.error("Failed to send digest to user {}: {}", user.getId(), e.getMessage());
            }
        }
    }

    private void sendViaChannel(NotificationChannel channel, User user, 
                                 NotificationTemplate template, Map<String, Object> variables) {
        switch (channel) {
            case EMAIL -> emailService.send(
                user.getEmail(),
                template.getSubject(),
                template.renderBody(variables)
            );
            case SMS -> smsService.send(
                user.getPhoneNumber(),
                template.renderSmsBody(variables)
            );
            case PUSH -> pushService.send(
                user.getDeviceTokens(),
                template.getTitle(),
                template.renderPushBody(variables)
            );
        }
    }

    private void sendToAllChannels(User user, NotificationTemplate template, 
                                    Map<String, Object> variables, NotificationType type) {
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        List<NotificationChannel> channels = determineChannels(prefs, type);
        
        for (NotificationChannel channel : channels) {
            try {
                sendViaChannel(channel, user, template, variables);
                logNotification(user.getId(), type, channel, "SUCCESS");
            } catch (Exception e) {
                log.error("Notification failed: {} via {} - {}", type, channel, e.getMessage());
                logNotification(user.getId(), type, channel, "FAILED");
            }
        }
    }

    private List<NotificationChannel> determineChannels(NotificationPreferences prefs, 
                                                         NotificationType type) {
        return prefs.getChannelPreferences().entrySet().stream()
            .filter(e -> e.getValue().contains(type))
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }

    private void logNotification(Long userId, NotificationType type, 
                                  NotificationChannel channel, String status) {
        NotificationLog log = NotificationLog.builder()
            .userId(userId)
            .type(type)
            .channel(channel)
            .status(status)
            .sentAt(Instant.now())
            .build();
        
        notificationRepository.save(log);
    }

    private Map<String, Object> buildOrderVariables(Order order) {
        return Map.of(
            "orderId", order.getId(),
            "items", order.getItems(),
            "subtotal", order.getSubtotal(),
            "tax", order.getTax(),
            "shipping", order.getShippingCost(),
            "total", order.getTotal(),
            "shippingAddress", order.getShippingAddress(),
            "estimatedDelivery", calculateEstimatedDelivery(order)
        );
    }
}
```

================================================================================
## MODULE 6: Reporting and Analytics
================================================================================

```java
package com.example.analytics.service;

import org.springframework.stereotype.Service;
import org.springframework.cache.annotation.Cacheable;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class AnalyticsService {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;
    private final InventoryRepository inventoryRepository;
    private final RevenueCalculator revenueCalculator;

    @Cacheable(value = "salesReport", key = "#startDate + '-' + #endDate")
    public SalesReport generateSalesReport(LocalDate startDate, LocalDate endDate) {
        log.info("Generating sales report for {} to {}", startDate, endDate);
        
        List<Order> orders = orderRepository.findByCreatedAtBetween(
            startDate.atStartOfDay().toInstant(ZoneOffset.UTC),
            endDate.plusDays(1).atStartOfDay().toInstant(ZoneOffset.UTC)
        );
        
        // Filter completed orders only
        List<Order> completedOrders = orders.stream()
            .filter(o -> o.getStatus() == OrderStatus.COMPLETED || 
                        o.getStatus() == OrderStatus.DELIVERED)
            .collect(Collectors.toList());
        
        // Calculate metrics
        BigDecimal totalRevenue = completedOrders.stream()
            .map(Order::getTotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal totalTax = completedOrders.stream()
            .map(Order::getTax)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal averageOrderValue = completedOrders.isEmpty() 
            ? BigDecimal.ZERO 
            : totalRevenue.divide(BigDecimal.valueOf(completedOrders.size()), RoundingMode.HALF_UP);
        
        // Daily breakdown
        Map<LocalDate, DailySales> dailyBreakdown = completedOrders.stream()
            .collect(Collectors.groupingBy(
                o -> o.getCreatedAt().atZone(ZoneOffset.UTC).toLocalDate(),
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    this::calculateDailySales
                )
            ));
        
        // Top products
        List<ProductSales> topProducts = calculateTopProducts(completedOrders, 10);
        
        // Category breakdown
        Map<String, CategorySales> categoryBreakdown = calculateCategoryBreakdown(completedOrders);
        
        return SalesReport.builder()
            .startDate(startDate)
            .endDate(endDate)
            .totalOrders(completedOrders.size())
            .totalRevenue(totalRevenue)
            .totalTax(totalTax)
            .averageOrderValue(averageOrderValue)
            .dailyBreakdown(dailyBreakdown)
            .topProducts(topProducts)
            .categoryBreakdown(categoryBreakdown)
            .generatedAt(Instant.now())
            .build();
    }

    @Cacheable(value = "customerAnalytics", key = "#customerId")
    public CustomerAnalytics getCustomerAnalytics(Long customerId) {
        User customer = userRepository.findById(customerId)
            .orElseThrow(() -> new UserNotFoundException(customerId));
        
        List<Order> orders = orderRepository.findByCustomerId(customerId);
        
        BigDecimal totalSpent = orders.stream()
            .filter(o -> o.getStatus() == OrderStatus.COMPLETED)
            .map(Order::getTotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal averageOrderValue = orders.isEmpty() 
            ? BigDecimal.ZERO 
            : totalSpent.divide(BigDecimal.valueOf(orders.size()), RoundingMode.HALF_UP);
        
        // Purchase frequency
        long daysSinceFirstOrder = orders.isEmpty() ? 0 :
            ChronoUnit.DAYS.between(
                orders.stream().map(Order::getCreatedAt).min(Instant::compareTo).get()
                    .atZone(ZoneOffset.UTC).toLocalDate(),
                LocalDate.now()
            );
        
        double ordersPerMonth = daysSinceFirstOrder > 0 
            ? (double) orders.size() / (daysSinceFirstOrder / 30.0) 
            : 0;
        
        // Favorite categories
        Map<String, Long> categoryPreferences = orders.stream()
            .flatMap(o -> o.getItems().stream())
            .collect(Collectors.groupingBy(
                item -> productRepository.findById(item.getProductId())
                    .map(Product::getCategory)
                    .orElse("Unknown"),
                Collectors.counting()
            ));
        
        // Customer segment
        CustomerSegment segment = determineCustomerSegment(totalSpent, orders.size(), ordersPerMonth);
        
        return CustomerAnalytics.builder()
            .customerId(customerId)
            .customerName(customer.getName())
            .memberSince(customer.getCreatedAt())
            .totalOrders(orders.size())
            .totalSpent(totalSpent)
            .averageOrderValue(averageOrderValue)
            .ordersPerMonth(ordersPerMonth)
            .categoryPreferences(categoryPreferences)
            .segment(segment)
            .lastOrderDate(orders.stream()
                .map(Order::getCreatedAt)
                .max(Instant::compareTo)
                .orElse(null))
            .build();
    }

    public InventoryReport generateInventoryReport() {
        List<InventoryItem> allItems = inventoryRepository.findAll();
        
        // Group by product
        Map<Long, List<InventoryItem>> byProduct = allItems.stream()
            .collect(Collectors.groupingBy(InventoryItem::getProductId));
        
        List<ProductInventoryStatus> productStatuses = byProduct.entrySet().stream()
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                List<InventoryItem> items = entry.getValue();
                
                int totalOnHand = items.stream().mapToInt(InventoryItem::getQuantityOnHand).sum();
                int totalReserved = items.stream().mapToInt(InventoryItem::getQuantityReserved).sum();
                
                InventoryHealthStatus health = determineHealthStatus(items);
                
                return ProductInventoryStatus.builder()
                    .productId(entry.getKey())
                    .productName(product != null ? product.getName() : "Unknown")
                    .totalOnHand(totalOnHand)
                    .totalReserved(totalReserved)
                    .totalAvailable(totalOnHand - totalReserved)
                    .health(health)
                    .warehouseBreakdown(items.stream()
                        .collect(Collectors.toMap(
                            InventoryItem::getWarehouseId,
                            i -> i.getQuantityOnHand() - i.getQuantityReserved()
                        )))
                    .build();
            })
            .sorted(Comparator.comparing(ProductInventoryStatus::getHealth))
            .collect(Collectors.toList());
        
        // Summary metrics
        long criticalItems = productStatuses.stream()
            .filter(p -> p.getHealth() == InventoryHealthStatus.CRITICAL)
            .count();
        
        long lowStockItems = productStatuses.stream()
            .filter(p -> p.getHealth() == InventoryHealthStatus.LOW)
            .count();
        
        BigDecimal totalInventoryValue = productStatuses.stream()
            .map(p -> {
                Product product = productRepository.findById(p.getProductId()).orElse(null);
                return product != null 
                    ? product.getCost().multiply(BigDecimal.valueOf(p.getTotalOnHand()))
                    : BigDecimal.ZERO;
            })
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        return InventoryReport.builder()
            .generatedAt(Instant.now())
            .totalProducts(productStatuses.size())
            .criticalStockItems(criticalItems)
            .lowStockItems(lowStockItems)
            .healthyStockItems(productStatuses.size() - criticalItems - lowStockItems)
            .totalInventoryValue(totalInventoryValue)
            .productStatuses(productStatuses)
            .build();
    }

    @Scheduled(cron = "0 0 1 * * *")
    public void generateDailyMetrics() {
        LocalDate yesterday = LocalDate.now().minusDays(1);
        
        DailyMetrics metrics = DailyMetrics.builder()
            .date(yesterday)
            .salesReport(generateSalesReport(yesterday, yesterday))
            .newCustomers(userRepository.countByCreatedAtBetween(
                yesterday.atStartOfDay().toInstant(ZoneOffset.UTC),
                yesterday.plusDays(1).atStartOfDay().toInstant(ZoneOffset.UTC)
            ))
            .activeUsers(sessionRepository.countDistinctUsersByDate(yesterday))
            .conversionRate(calculateConversionRate(yesterday))
            .build();
        
        metricsRepository.save(metrics);
        
        log.info("Daily metrics generated for {}: {} orders, {} revenue", 
            yesterday, metrics.getSalesReport().getTotalOrders(), 
            metrics.getSalesReport().getTotalRevenue());
    }

    private DailySales calculateDailySales(List<Order> orders) {
        return DailySales.builder()
            .orderCount(orders.size())
            .revenue(orders.stream()
                .map(Order::getTotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add))
            .build();
    }

    private List<ProductSales> calculateTopProducts(List<Order> orders, int limit) {
        Map<Long, ProductSalesAccumulator> accumulator = new HashMap<>();
        
        for (Order order : orders) {
            for (OrderItem item : order.getItems()) {
                accumulator.computeIfAbsent(item.getProductId(), 
                    k -> new ProductSalesAccumulator(item.getProductId(), item.getProductName()))
                    .add(item.getQuantity(), item.getTotalPrice());
            }
        }
        
        return accumulator.values().stream()
            .sorted(Comparator.comparing(ProductSalesAccumulator::getRevenue).reversed())
            .limit(limit)
            .map(ProductSalesAccumulator::toProductSales)
            .collect(Collectors.toList());
    }

    private Map<String, CategorySales> calculateCategoryBreakdown(List<Order> orders) {
        Map<String, CategorySalesAccumulator> accumulator = new HashMap<>();
        
        for (Order order : orders) {
            for (OrderItem item : order.getItems()) {
                String category = productRepository.findById(item.getProductId())
                    .map(Product::getCategory)
                    .orElse("Uncategorized");
                
                accumulator.computeIfAbsent(category, CategorySalesAccumulator::new)
                    .add(item.getQuantity(), item.getTotalPrice());
            }
        }
        
        return accumulator.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().toCategorySales()
            ));
    }

    private CustomerSegment determineCustomerSegment(BigDecimal totalSpent, int orderCount, 
                                                      double ordersPerMonth) {
        if (totalSpent.compareTo(BigDecimal.valueOf(10000)) > 0 && ordersPerMonth > 2) {
            return CustomerSegment.VIP;
        } else if (totalSpent.compareTo(BigDecimal.valueOf(5000)) > 0 && ordersPerMonth > 1) {
            return CustomerSegment.LOYAL;
        } else if (orderCount > 5) {
            return CustomerSegment.REGULAR;
        } else if (orderCount > 0) {
            return CustomerSegment.OCCASIONAL;
        } else {
            return CustomerSegment.NEW;
        }
    }

    private InventoryHealthStatus determineHealthStatus(List<InventoryItem> items) {
        int totalAvailable = items.stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        int avgReorderPoint = (int) items.stream()
            .mapToInt(InventoryItem::getReorderPoint)
            .average()
            .orElse(0);
        
        if (totalAvailable <= 0) {
            return InventoryHealthStatus.OUT_OF_STOCK;
        } else if (totalAvailable <= avgReorderPoint / 2) {
            return InventoryHealthStatus.CRITICAL;
        } else if (totalAvailable <= avgReorderPoint) {
            return InventoryHealthStatus.LOW;
        } else {
            return InventoryHealthStatus.HEALTHY;
        }
    }
}
```

================================================================================
## MODULE 7: Search and Recommendation Engine
================================================================================

```java
package com.example.search.service;

import org.springframework.stereotype.Service;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class SearchAndRecommendationService {

    private final RestHighLevelClient elasticsearchClient;
    private final ProductRepository productRepository;
    private final UserBehaviorRepository behaviorRepository;
    private final SimilarityCalculator similarityCalculator;
    private final MLRecommendationClient mlClient;

    public SearchResults search(SearchRequest request) {
        log.info("Searching for: {} with filters: {}", request.getQuery(), request.getFilters());
        
        SearchSourceBuilder searchBuilder = new SearchSourceBuilder();
        
        // Build query
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // Full-text search on name, description, tags
        if (StringUtils.isNotBlank(request.getQuery())) {
            boolQuery.must(QueryBuilders.multiMatchQuery(request.getQuery())
                .field("name", 3.0f)
                .field("description", 1.0f)
                .field("tags", 2.0f)
                .field("category", 1.5f)
                .fuzziness(Fuzziness.AUTO)
                .prefixLength(2));
        }
        
        // Apply filters
        if (request.getFilters() != null) {
            applyFilters(boolQuery, request.getFilters());
        }
        
        searchBuilder.query(boolQuery);
        
        // Sorting
        if (request.getSortBy() != null) {
            searchBuilder.sort(request.getSortBy(), 
                request.getSortOrder() == SortOrder.DESC ? SortOrder.DESC : SortOrder.ASC);
        } else {
            searchBuilder.sort("_score", SortOrder.DESC);
        }
        
        // Pagination
        searchBuilder.from(request.getPage() * request.getSize());
        searchBuilder.size(request.getSize());
        
        // Execute search
        SearchResponse response = elasticsearchClient.search(
            new SearchRequest("products").source(searchBuilder),
            RequestOptions.DEFAULT
        );
        
        // Map results
        List<ProductSearchResult> results = Arrays.stream(response.getHits().getHits())
            .map(hit -> {
                Map<String, Object> source = hit.getSourceAsMap();
                return ProductSearchResult.builder()
                    .productId(Long.parseLong(hit.getId()))
                    .name((String) source.get("name"))
                    .description((String) source.get("description"))
                    .price(new BigDecimal(source.get("price").toString()))
                    .category((String) source.get("category"))
                    .imageUrl((String) source.get("imageUrl"))
                    .rating((Double) source.get("rating"))
                    .score(hit.getScore())
                    .build();
            })
            .collect(Collectors.toList());
        
        // Get facets/aggregations
        Map<String, List<FacetValue>> facets = extractFacets(response.getAggregations());
        
        // Log search for analytics
        logSearchEvent(request, response.getHits().getTotalHits().value);
        
        return SearchResults.builder()
            .query(request.getQuery())
            .results(results)
            .totalHits(response.getHits().getTotalHits().value)
            .page(request.getPage())
            .size(request.getSize())
            .facets(facets)
            .searchTime(response.getTook().getMillis())
            .build();
    }

    public List<ProductRecommendation> getPersonalizedRecommendations(Long userId, int limit) {
        log.debug("Getting personalized recommendations for user: {}", userId);
        
        // Get user behavior history
        UserBehaviorProfile profile = buildUserProfile(userId);
        
        // Try ML-based recommendations first
        try {
            List<Long> mlRecommendations = mlClient.getRecommendations(userId, limit * 2);
            
            if (!mlRecommendations.isEmpty()) {
                return mlRecommendations.stream()
                    .map(productId -> productRepository.findById(productId).orElse(null))
                    .filter(Objects::nonNull)
                    .filter(p -> !profile.getPurchasedProductIds().contains(p.getId()))
                    .limit(limit)
                    .map(p -> ProductRecommendation.builder()
                        .product(p)
                        .reason("Based on your shopping history")
                        .score(0.9)
                        .build())
                    .collect(Collectors.toList());
            }
        } catch (Exception e) {
            log.warn("ML recommendation service unavailable, falling back to rule-based", e);
        }
        
        // Fallback: Rule-based recommendations
        return getRuleBasedRecommendations(profile, limit);
    }

    public List<ProductRecommendation> getSimilarProducts(Long productId, int limit) {
        Product baseProduct = productRepository.findById(productId)
            .orElseThrow(() -> new ProductNotFoundException(productId));
        
        // Get products in same category
        List<Product> categoryProducts = productRepository.findByCategory(baseProduct.getCategory());
        
        // Calculate similarity scores
        return categoryProducts.stream()
            .filter(p -> !p.getId().equals(productId))
            .map(p -> {
                double similarity = similarityCalculator.calculate(baseProduct, p);
                return ProductRecommendation.builder()
                    .product(p)
                    .reason("Similar to " + baseProduct.getName())
                    .score(similarity)
                    .build();
            })
            .filter(r -> r.getScore() > 0.3)
            .sorted(Comparator.comparing(ProductRecommendation::getScore).reversed())
            .limit(limit)
            .collect(Collectors.toList());
    }

    public List<ProductRecommendation> getFrequentlyBoughtTogether(Long productId, int limit) {
        // Find orders containing this product
        List<Order> ordersWithProduct = orderRepository.findByItemsProductId(productId);
        
        // Count co-occurrence of other products
        Map<Long, Long> coOccurrence = ordersWithProduct.stream()
            .flatMap(o -> o.getItems().stream())
            .map(OrderItem::getProductId)
            .filter(id -> !id.equals(productId))
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        
        // Get top co-occurring products
        return coOccurrence.entrySet().stream()
            .sorted(Map.Entry.<Long, Long>comparingByValue().reversed())
            .limit(limit)
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                if (product == null) return null;
                
                double score = (double) entry.getValue() / ordersWithProduct.size();
                return ProductRecommendation.builder()
                    .product(product)
                    .reason("Frequently bought together")
                    .score(score)
                    .build();
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }

    public List<ProductRecommendation> getTrendingProducts(int limit) {
        LocalDate weekAgo = LocalDate.now().minusDays(7);
        
        // Get recent orders
        List<Order> recentOrders = orderRepository.findByCreatedAtAfter(
            weekAgo.atStartOfDay().toInstant(ZoneOffset.UTC)
        );
        
        // Count product sales with recency weighting
        Map<Long, Double> trendingScores = new HashMap<>();
        
        for (Order order : recentOrders) {
            long daysAgo = ChronoUnit.DAYS.between(
                order.getCreatedAt().atZone(ZoneOffset.UTC).toLocalDate(),
                LocalDate.now()
            );
            double recencyWeight = 1.0 / (1.0 + daysAgo * 0.1);
            
            for (OrderItem item : order.getItems()) {
                trendingScores.merge(item.getProductId(), 
                    item.getQuantity() * recencyWeight, 
                    Double::sum);
            }
        }
        
        // Normalize and return top trending
        double maxScore = trendingScores.values().stream()
            .max(Double::compareTo)
            .orElse(1.0);
        
        return trendingScores.entrySet().stream()
            .sorted(Map.Entry.<Long, Double>comparingByValue().reversed())
            .limit(limit)
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                if (product == null) return null;
                
                return ProductRecommendation.builder()
                    .product(product)
                    .reason("Trending this week")
                    .score(entry.getValue() / maxScore)
                    .build();
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }

    @Async
    public void trackUserBehavior(Long userId, BehaviorEvent event) {
        UserBehavior behavior = UserBehavior.builder()
            .userId(userId)
            .eventType(event.getType())
            .productId(event.getProductId())
            .searchQuery(event.getSearchQuery())
            .timestamp(Instant.now())
            .sessionId(event.getSessionId())
            .metadata(event.getMetadata())
            .build();
        
        behaviorRepository.save(behavior);
        
        // Update real-time recommendations cache if significant event
        if (event.getType() == BehaviorType.PURCHASE || 
            event.getType() == BehaviorType.ADD_TO_CART) {
            recommendationCache.invalidate(userId);
        }
    }

    private void applyFilters(BoolQueryBuilder boolQuery, SearchFilters filters) {
        if (filters.getCategories() != null && !filters.getCategories().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("category", filters.getCategories()));
        }
        
        if (filters.getMinPrice() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("price").gte(filters.getMinPrice()));
        }
        
        if (filters.getMaxPrice() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("price").lte(filters.getMaxPrice()));
        }
        
        if (filters.getMinRating() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("rating").gte(filters.getMinRating()));
        }
        
        if (filters.getInStock() != null && filters.getInStock()) {
            boolQuery.filter(QueryBuilders.termQuery("inStock", true));
        }
        
        if (filters.getBrands() != null && !filters.getBrands().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("brand", filters.getBrands()));
        }
        
        if (filters.getTags() != null && !filters.getTags().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("tags", filters.getTags()));
        }
    }

    private UserBehaviorProfile buildUserProfile(Long userId) {
        List<UserBehavior> behaviors = behaviorRepository.findByUserIdOrderByTimestampDesc(
            userId, PageRequest.of(0, 1000)
        );
        
        Set<Long> purchasedProducts = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.PURCHASE)
            .map(UserBehavior::getProductId)
            .collect(Collectors.toSet());
        
        Set<Long> viewedProducts = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.VIEW)
            .map(UserBehavior::getProductId)
            .collect(Collectors.toSet());
        
        Map<String, Long> categoryInterests = behaviors.stream()
            .filter(b -> b.getProductId() != null)
            .map(b -> productRepository.findById(b.getProductId())
                .map(Product::getCategory)
                .orElse(null))
            .filter(Objects::nonNull)
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        
        List<String> recentSearches = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.SEARCH)
            .map(UserBehavior::getSearchQuery)
            .filter(Objects::nonNull)
            .limit(20)
            .collect(Collectors.toList());
        
        return UserBehaviorProfile.builder()
            .userId(userId)
            .purchasedProductIds(purchasedProducts)
            .viewedProductIds(viewedProducts)
            .categoryInterests(categoryInterests)
            .recentSearches(recentSearches)
            .build();
    }

    private List<ProductRecommendation> getRuleBasedRecommendations(UserBehaviorProfile profile, 
                                                                      int limit) {
        List<ProductRecommendation> recommendations = new ArrayList<>();
        
        // 1. Products from favorite categories
        String topCategory = profile.getCategoryInterests().entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
        
        if (topCategory != null) {
            productRepository.findByCategoryAndIdNotIn(topCategory, profile.getPurchasedProductIds())
                .stream()
                .limit(limit / 2)
                .forEach(p -> recommendations.add(ProductRecommendation.builder()
                    .product(p)
                    .reason("Based on your interest in " + topCategory)
                    .score(0.7)
                    .build()));
        }
        
        // 2. Highly rated products user hasn't purchased
        productRepository.findTopRatedNotPurchased(profile.getPurchasedProductIds(), limit / 2)
            .forEach(p -> recommendations.add(ProductRecommendation.builder()
                .product(p)
                .reason("Top rated product")
                .score(0.6)
                .build()));
        
        return recommendations.stream()
            .distinct()
            .limit(limit)
            .collect(Collectors.toList());
    }
}
```

================================================================================
## END OF FILE - REPEAT SECTION FOR SIZE
================================================================================
# Large Codebase Simulation File
# This file simulates a large codebase for context overflow testing
# Generated for focus-task plugin testing

================================================================================
## MODULE 1: Authentication Service
================================================================================

```java
package com.example.auth.service;

import org.springframework.stereotype.Service;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class AuthenticationService {

    private final UserRepository userRepository;
    private final TokenService tokenService;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AuditLogService auditLogService;

    public AuthResponse authenticate(AuthRequest request) {
        log.info("Authentication attempt for user: {}", request.getUsername());
        
        User user = userRepository.findByUsername(request.getUsername())
            .orElseThrow(() -> new AuthenticationException("User not found"));
        
        if (!passwordEncoder.matches(request.getPassword(), user.getPasswordHash())) {
            auditLogService.logFailedLogin(user.getId(), request.getIpAddress());
            throw new AuthenticationException("Invalid credentials");
        }
        
        if (!user.isEnabled()) {
            throw new AuthenticationException("Account disabled");
        }
        
        String accessToken = tokenService.generateAccessToken(user);
        String refreshToken = tokenService.generateRefreshToken(user);
        
        auditLogService.logSuccessfulLogin(user.getId(), request.getIpAddress());
        
        return AuthResponse.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .expiresIn(tokenService.getAccessTokenExpiration())
            .tokenType("Bearer")
            .build();
    }

    public AuthResponse refreshToken(String refreshToken) {
        TokenClaims claims = tokenService.validateRefreshToken(refreshToken);
        
        User user = userRepository.findById(claims.getUserId())
            .orElseThrow(() -> new AuthenticationException("User not found"));
        
        String newAccessToken = tokenService.generateAccessToken(user);
        
        return AuthResponse.builder()
            .accessToken(newAccessToken)
            .refreshToken(refreshToken)
            .expiresIn(tokenService.getAccessTokenExpiration())
            .tokenType("Bearer")
            .build();
    }

    public void logout(String accessToken) {
        tokenService.revokeToken(accessToken);
        log.info("User logged out successfully");
    }

    public void changePassword(Long userId, ChangePasswordRequest request) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException(userId));
        
        if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPasswordHash())) {
            throw new AuthenticationException("Current password is incorrect");
        }
        
        validatePasswordStrength(request.getNewPassword());
        
        user.setPasswordHash(passwordEncoder.encode(request.getNewPassword()));
        user.setPasswordChangedAt(Instant.now());
        userRepository.save(user);
        
        tokenService.revokeAllUserTokens(userId);
        auditLogService.logPasswordChange(userId);
    }

    private void validatePasswordStrength(String password) {
        if (password.length() < 12) {
            throw new ValidationException("Password must be at least 12 characters");
        }
        if (!password.matches(".*[A-Z].*")) {
            throw new ValidationException("Password must contain uppercase letter");
        }
        if (!password.matches(".*[a-z].*")) {
            throw new ValidationException("Password must contain lowercase letter");
        }
        if (!password.matches(".*\\d.*")) {
            throw new ValidationException("Password must contain digit");
        }
        if (!password.matches(".*[!@#$%^&*()].*")) {
            throw new ValidationException("Password must contain special character");
        }
    }
}
```

================================================================================
## MODULE 2: Order Processing Service
================================================================================

```java
package com.example.orders.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class OrderProcessingService {

    private final OrderRepository orderRepository;
    private final ProductService productService;
    private final InventoryService inventoryService;
    private final PaymentService paymentService;
    private final NotificationService notificationService;
    private final ShippingService shippingService;
    private final TaxCalculationService taxService;
    private final DiscountService discountService;

    @Transactional
    public OrderResponse createOrder(CreateOrderRequest request) {
        log.info("Creating order for customer: {}", request.getCustomerId());
        
        // Validate products availability
        List<OrderItem> items = request.getItems().stream()
            .map(this::validateAndCreateOrderItem)
            .collect(Collectors.toList());
        
        // Calculate totals
        BigDecimal subtotal = calculateSubtotal(items);
        BigDecimal discount = discountService.calculateDiscount(request.getPromoCode(), subtotal);
        BigDecimal tax = taxService.calculateTax(subtotal.subtract(discount), request.getShippingAddress());
        BigDecimal shippingCost = shippingService.calculateShippingCost(items, request.getShippingAddress());
        BigDecimal total = subtotal.subtract(discount).add(tax).add(shippingCost);
        
        // Create order
        Order order = Order.builder()
            .customerId(request.getCustomerId())
            .items(items)
            .subtotal(subtotal)
            .discount(discount)
            .tax(tax)
            .shippingCost(shippingCost)
            .total(total)
            .status(OrderStatus.PENDING)
            .shippingAddress(request.getShippingAddress())
            .billingAddress(request.getBillingAddress())
            .createdAt(Instant.now())
            .build();
        
        order = orderRepository.save(order);
        
        // Reserve inventory
        items.forEach(item -> inventoryService.reserveStock(item.getProductId(), item.getQuantity()));
        
        log.info("Order {} created successfully with total: {}", order.getId(), total);
        
        return mapToResponse(order);
    }

    @Transactional
    public OrderResponse processPayment(Long orderId, PaymentRequest paymentRequest) {
        Order order = getOrderOrThrow(orderId);
        
        if (order.getStatus() != OrderStatus.PENDING) {
            throw new OrderProcessingException("Order is not in pending status");
        }
        
        PaymentResult result = paymentService.processPayment(
            paymentRequest.getPaymentMethodId(),
            order.getTotal(),
            order.getId().toString()
        );
        
        if (result.isSuccessful()) {
            order.setStatus(OrderStatus.PAID);
            order.setPaymentId(result.getTransactionId());
            order.setPaidAt(Instant.now());
            
            // Commit inventory reservation
            order.getItems().forEach(item -> 
                inventoryService.commitReservation(item.getProductId(), item.getQuantity()));
            
            // Trigger fulfillment
            shippingService.createShipment(order);
            
            // Send confirmation
            notificationService.sendOrderConfirmation(order);
            
            log.info("Payment processed successfully for order: {}", orderId);
        } else {
            order.setStatus(OrderStatus.PAYMENT_FAILED);
            order.setPaymentError(result.getErrorMessage());
            
            // Release inventory reservation
            order.getItems().forEach(item -> 
                inventoryService.releaseReservation(item.getProductId(), item.getQuantity()));
            
            log.warn("Payment failed for order: {} - {}", orderId, result.getErrorMessage());
        }
        
        orderRepository.save(order);
        return mapToResponse(order);
    }

    @Transactional
    public OrderResponse cancelOrder(Long orderId, String reason) {
        Order order = getOrderOrThrow(orderId);
        
        if (!order.getStatus().isCancellable()) {
            throw new OrderProcessingException("Order cannot be cancelled in current status");
        }
        
        // Refund if already paid
        if (order.getPaymentId() != null) {
            paymentService.refund(order.getPaymentId(), order.getTotal());
        }
        
        // Release inventory
        order.getItems().forEach(item -> 
            inventoryService.releaseStock(item.getProductId(), item.getQuantity()));
        
        order.setStatus(OrderStatus.CANCELLED);
        order.setCancellationReason(reason);
        order.setCancelledAt(Instant.now());
        
        orderRepository.save(order);
        
        notificationService.sendOrderCancellation(order);
        
        log.info("Order {} cancelled: {}", orderId, reason);
        
        return mapToResponse(order);
    }

    public List<OrderResponse> getCustomerOrders(Long customerId, Pageable pageable) {
        return orderRepository.findByCustomerId(customerId, pageable)
            .stream()
            .map(this::mapToResponse)
            .collect(Collectors.toList());
    }

    public OrderResponse getOrderDetails(Long orderId) {
        return mapToResponse(getOrderOrThrow(orderId));
    }

    private OrderItem validateAndCreateOrderItem(OrderItemRequest request) {
        Product product = productService.getProduct(request.getProductId());
        
        if (!product.isAvailable()) {
            throw new ProductNotAvailableException(product.getId());
        }
        
        if (!inventoryService.hasStock(product.getId(), request.getQuantity())) {
            throw new InsufficientStockException(product.getId(), request.getQuantity());
        }
        
        return OrderItem.builder()
            .productId(product.getId())
            .productName(product.getName())
            .quantity(request.getQuantity())
            .unitPrice(product.getPrice())
            .totalPrice(product.getPrice().multiply(BigDecimal.valueOf(request.getQuantity())))
            .build();
    }

    private BigDecimal calculateSubtotal(List<OrderItem> items) {
        return items.stream()
            .map(OrderItem::getTotalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    private Order getOrderOrThrow(Long orderId) {
        return orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
    }

    private OrderResponse mapToResponse(Order order) {
        return OrderResponse.builder()
            .id(order.getId())
            .customerId(order.getCustomerId())
            .items(order.getItems().stream()
                .map(this::mapItemToResponse)
                .collect(Collectors.toList()))
            .subtotal(order.getSubtotal())
            .discount(order.getDiscount())
            .tax(order.getTax())
            .shippingCost(order.getShippingCost())
            .total(order.getTotal())
            .status(order.getStatus())
            .createdAt(order.getCreatedAt())
            .build();
    }

    private OrderItemResponse mapItemToResponse(OrderItem item) {
        return OrderItemResponse.builder()
            .productId(item.getProductId())
            .productName(item.getProductName())
            .quantity(item.getQuantity())
            .unitPrice(item.getUnitPrice())
            .totalPrice(item.getTotalPrice())
            .build();
    }
}
```

================================================================================
## MODULE 3: Inventory Management System
================================================================================

```java
package com.example.inventory.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
@Slf4j
@RequiredArgsConstructor
public class InventoryManagementService {

    private final InventoryRepository inventoryRepository;
    private final WarehouseRepository warehouseRepository;
    private final ReorderService reorderService;
    private final NotificationService notificationService;
    private final AuditService auditService;
    
    private final Map<String, ReservationLock> reservationLocks = new ConcurrentHashMap<>();

    @Transactional
    public InventoryItem addStock(Long productId, Long warehouseId, int quantity, String reason) {
        log.info("Adding {} units of product {} to warehouse {}", quantity, productId, warehouseId);
        
        InventoryItem item = getOrCreateInventoryItem(productId, warehouseId);
        int previousQuantity = item.getQuantityOnHand();
        
        item.setQuantityOnHand(item.getQuantityOnHand() + quantity);
        item.setLastRestockedAt(Instant.now());
        
        inventoryRepository.save(item);
        
        auditService.logInventoryChange(
            productId, warehouseId, previousQuantity, item.getQuantityOnHand(), reason
        );
        
        checkReorderThreshold(item);
        
        return item;
    }

    @Transactional
    public synchronized boolean reserveStock(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdOrderByQuantityDesc(productId);
        
        int totalAvailable = items.stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        if (totalAvailable < quantity) {
            log.warn("Insufficient stock for product {}: requested {}, available {}", 
                productId, quantity, totalAvailable);
            return false;
        }
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int available = item.getQuantityOnHand() - item.getQuantityReserved();
            int toReserve = Math.min(available, remaining);
            
            if (toReserve > 0) {
                item.setQuantityReserved(item.getQuantityReserved() + toReserve);
                inventoryRepository.save(item);
                remaining -= toReserve;
                
                log.debug("Reserved {} units from warehouse {} for product {}", 
                    toReserve, item.getWarehouseId(), productId);
            }
        }
        
        return true;
    }

    @Transactional
    public void commitReservation(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdAndQuantityReservedGreaterThan(productId, 0);
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int toCommit = Math.min(item.getQuantityReserved(), remaining);
            
            item.setQuantityOnHand(item.getQuantityOnHand() - toCommit);
            item.setQuantityReserved(item.getQuantityReserved() - toCommit);
            inventoryRepository.save(item);
            
            remaining -= toCommit;
            
            checkReorderThreshold(item);
        }
        
        log.info("Committed reservation of {} units for product {}", quantity, productId);
    }

    @Transactional
    public void releaseReservation(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdAndQuantityReservedGreaterThan(productId, 0);
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int toRelease = Math.min(item.getQuantityReserved(), remaining);
            item.setQuantityReserved(item.getQuantityReserved() - toRelease);
            inventoryRepository.save(item);
            
            remaining -= toRelease;
        }
        
        log.info("Released reservation of {} units for product {}", quantity, productId);
    }

    public boolean hasStock(Long productId, int quantity) {
        int available = inventoryRepository.findByProductId(productId).stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        return available >= quantity;
    }

    public InventoryStatus getInventoryStatus(Long productId) {
        List<InventoryItem> items = inventoryRepository.findByProductId(productId);
        
        int totalOnHand = items.stream().mapToInt(InventoryItem::getQuantityOnHand).sum();
        int totalReserved = items.stream().mapToInt(InventoryItem::getQuantityReserved).sum();
        int totalAvailable = totalOnHand - totalReserved;
        
        return InventoryStatus.builder()
            .productId(productId)
            .totalOnHand(totalOnHand)
            .totalReserved(totalReserved)
            .totalAvailable(totalAvailable)
            .warehouseBreakdown(items.stream()
                .collect(Collectors.toMap(
                    InventoryItem::getWarehouseId,
                    i -> new WarehouseStock(i.getQuantityOnHand(), i.getQuantityReserved())
                )))
            .build();
    }

    @Scheduled(cron = "0 0 * * * *")
    public void checkLowStockLevels() {
        log.info("Running scheduled low stock check");
        
        List<InventoryItem> lowStockItems = inventoryRepository.findItemsBelowReorderPoint();
        
        for (InventoryItem item : lowStockItems) {
            if (!reorderService.hasPendingReorder(item.getProductId())) {
                ReorderRequest request = calculateReorderQuantity(item);
                reorderService.createReorderRequest(request);
                
                notificationService.sendLowStockAlert(item);
                
                log.info("Created reorder request for product {} at warehouse {}", 
                    item.getProductId(), item.getWarehouseId());
            }
        }
    }

    @Transactional
    public void transferStock(Long productId, Long fromWarehouse, Long toWarehouse, int quantity) {
        InventoryItem source = inventoryRepository.findByProductIdAndWarehouseId(productId, fromWarehouse)
            .orElseThrow(() -> new InventoryNotFoundException(productId, fromWarehouse));
        
        int available = source.getQuantityOnHand() - source.getQuantityReserved();
        if (available < quantity) {
            throw new InsufficientStockException(productId, quantity);
        }
        
        source.setQuantityOnHand(source.getQuantityOnHand() - quantity);
        inventoryRepository.save(source);
        
        InventoryItem destination = getOrCreateInventoryItem(productId, toWarehouse);
        destination.setQuantityOnHand(destination.getQuantityOnHand() + quantity);
        inventoryRepository.save(destination);
        
        auditService.logStockTransfer(productId, fromWarehouse, toWarehouse, quantity);
        
        log.info("Transferred {} units of product {} from warehouse {} to {}", 
            quantity, productId, fromWarehouse, toWarehouse);
    }

    private InventoryItem getOrCreateInventoryItem(Long productId, Long warehouseId) {
        return inventoryRepository.findByProductIdAndWarehouseId(productId, warehouseId)
            .orElseGet(() -> {
                Warehouse warehouse = warehouseRepository.findById(warehouseId)
                    .orElseThrow(() -> new WarehouseNotFoundException(warehouseId));
                
                return InventoryItem.builder()
                    .productId(productId)
                    .warehouseId(warehouseId)
                    .quantityOnHand(0)
                    .quantityReserved(0)
                    .reorderPoint(warehouse.getDefaultReorderPoint())
                    .reorderQuantity(warehouse.getDefaultReorderQuantity())
                    .build();
            });
    }

    private void checkReorderThreshold(InventoryItem item) {
        int available = item.getQuantityOnHand() - item.getQuantityReserved();
        
        if (available <= item.getReorderPoint()) {
            log.info("Product {} at warehouse {} below reorder point: {} <= {}", 
                item.getProductId(), item.getWarehouseId(), available, item.getReorderPoint());
            
            if (!reorderService.hasPendingReorder(item.getProductId())) {
                ReorderRequest request = calculateReorderQuantity(item);
                reorderService.createReorderRequest(request);
            }
        }
    }

    private ReorderRequest calculateReorderQuantity(InventoryItem item) {
        // Calculate based on historical demand and lead time
        int suggestedQuantity = Math.max(
            item.getReorderQuantity(),
            (int) (demandForecastService.getAverageDailyDemand(item.getProductId()) * 
                   supplierService.getLeadTimeDays(item.getProductId()) * 1.5)
        );
        
        return ReorderRequest.builder()
            .productId(item.getProductId())
            .warehouseId(item.getWarehouseId())
            .quantity(suggestedQuantity)
            .priority(available <= item.getReorderPoint() / 2 ? Priority.HIGH : Priority.NORMAL)
            .build();
    }
}
```

================================================================================
## MODULE 4: Payment Processing Gateway
================================================================================

```java
package com.example.payment.service;

import org.springframework.stereotype.Service;
import org.springframework.retry.annotation.Retryable;
import org.springframework.retry.annotation.Backoff;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.math.BigDecimal;
import java.util.UUID;

@Service
@Slf4j
@RequiredArgsConstructor
public class PaymentGatewayService {

    private final StripeClient stripeClient;
    private final PayPalClient payPalClient;
    private final PaymentRepository paymentRepository;
    private final FraudDetectionService fraudDetectionService;
    private final CurrencyConversionService currencyService;
    private final PaymentEventPublisher eventPublisher;

    @Retryable(
        value = {PaymentGatewayException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public PaymentResult processPayment(PaymentRequest request) {
        log.info("Processing payment of {} {} for order {}", 
            request.getAmount(), request.getCurrency(), request.getOrderId());
        
        // Fraud check
        FraudCheckResult fraudResult = fraudDetectionService.checkTransaction(request);
        if (fraudResult.isBlocked()) {
            log.warn("Payment blocked by fraud detection: {}", fraudResult.getReason());
            return PaymentResult.failed(fraudResult.getReason());
        }
        
        // Create payment record
        Payment payment = Payment.builder()
            .id(UUID.randomUUID().toString())
            .orderId(request.getOrderId())
            .amount(request.getAmount())
            .currency(request.getCurrency())
            .paymentMethodId(request.getPaymentMethodId())
            .status(PaymentStatus.PROCESSING)
            .createdAt(Instant.now())
            .build();
        
        paymentRepository.save(payment);
        
        try {
            PaymentResult result = processWithGateway(request, payment);
            
            if (result.isSuccessful()) {
                payment.setStatus(PaymentStatus.COMPLETED);
                payment.setGatewayTransactionId(result.getTransactionId());
                payment.setCompletedAt(Instant.now());
                
                eventPublisher.publishPaymentCompleted(payment);
            } else {
                payment.setStatus(PaymentStatus.FAILED);
                payment.setErrorMessage(result.getErrorMessage());
                
                eventPublisher.publishPaymentFailed(payment);
            }
            
            paymentRepository.save(payment);
            return result;
            
        } catch (Exception e) {
            log.error("Payment processing error for order {}: {}", request.getOrderId(), e.getMessage());
            
            payment.setStatus(PaymentStatus.ERROR);
            payment.setErrorMessage(e.getMessage());
            paymentRepository.save(payment);
            
            throw new PaymentProcessingException("Payment processing failed", e);
        }
    }

    @Retryable(
        value = {RefundException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 2000, multiplier = 2)
    )
    public RefundResult refund(String paymentId, BigDecimal amount, String reason) {
        Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow(() -> new PaymentNotFoundException(paymentId));
        
        if (payment.getStatus() != PaymentStatus.COMPLETED) {
            throw new RefundException("Cannot refund payment in status: " + payment.getStatus());
        }
        
        BigDecimal refundedAmount = payment.getRefunds().stream()
            .map(Refund::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal maxRefundable = payment.getAmount().subtract(refundedAmount);
        if (amount.compareTo(maxRefundable) > 0) {
            throw new RefundException("Refund amount exceeds available: " + maxRefundable);
        }
        
        log.info("Processing refund of {} for payment {}", amount, paymentId);
        
        RefundResult result = switch (payment.getGateway()) {
            case STRIPE -> stripeClient.refund(payment.getGatewayTransactionId(), amount);
            case PAYPAL -> payPalClient.refund(payment.getGatewayTransactionId(), amount);
            default -> throw new UnsupportedGatewayException(payment.getGateway());
        };
        
        if (result.isSuccessful()) {
            Refund refund = Refund.builder()
                .id(UUID.randomUUID().toString())
                .paymentId(paymentId)
                .amount(amount)
                .reason(reason)
                .gatewayRefundId(result.getRefundId())
                .createdAt(Instant.now())
                .build();
            
            payment.getRefunds().add(refund);
            
            if (payment.getAmount().equals(refundedAmount.add(amount))) {
                payment.setStatus(PaymentStatus.FULLY_REFUNDED);
            } else {
                payment.setStatus(PaymentStatus.PARTIALLY_REFUNDED);
            }
            
            paymentRepository.save(payment);
            eventPublisher.publishRefundCompleted(refund);
        }
        
        return result;
    }

    public PaymentStatus getPaymentStatus(String paymentId) {
        return paymentRepository.findById(paymentId)
            .map(Payment::getStatus)
            .orElseThrow(() -> new PaymentNotFoundException(paymentId));
    }

    public List<Payment> getPaymentHistory(String orderId) {
        return paymentRepository.findByOrderId(orderId);
    }

    private PaymentResult processWithGateway(PaymentRequest request, Payment payment) {
        PaymentMethod method = paymentMethodRepository.findById(request.getPaymentMethodId())
            .orElseThrow(() -> new PaymentMethodNotFoundException(request.getPaymentMethodId()));
        
        // Currency conversion if needed
        BigDecimal processAmount = request.getAmount();
        String processCurrency = request.getCurrency();
        
        if (!method.getSupportedCurrencies().contains(request.getCurrency())) {
            CurrencyConversion conversion = currencyService.convert(
                request.getAmount(), 
                request.getCurrency(), 
                method.getDefaultCurrency()
            );
            processAmount = conversion.getConvertedAmount();
            processCurrency = conversion.getTargetCurrency();
            payment.setConversionRate(conversion.getRate());
        }
        
        PaymentGateway gateway = method.getGateway();
        payment.setGateway(gateway);
        
        return switch (gateway) {
            case STRIPE -> stripeClient.charge(
                method.getGatewayToken(),
                processAmount,
                processCurrency,
                payment.getId()
            );
            case PAYPAL -> payPalClient.charge(
                method.getGatewayToken(),
                processAmount,
                processCurrency,
                payment.getId()
            );
            default -> throw new UnsupportedGatewayException(gateway);
        };
    }

    @Scheduled(fixedRate = 60000)
    public void reconcilePendingPayments() {
        List<Payment> pendingPayments = paymentRepository.findByStatusAndCreatedAtBefore(
            PaymentStatus.PROCESSING,
            Instant.now().minus(Duration.ofMinutes(15))
        );
        
        for (Payment payment : pendingPayments) {
            try {
                PaymentStatus gatewayStatus = queryGatewayStatus(payment);
                
                if (gatewayStatus != payment.getStatus()) {
                    log.info("Reconciling payment {}: {} -> {}", 
                        payment.getId(), payment.getStatus(), gatewayStatus);
                    
                    payment.setStatus(gatewayStatus);
                    paymentRepository.save(payment);
                    
                    if (gatewayStatus == PaymentStatus.COMPLETED) {
                        eventPublisher.publishPaymentCompleted(payment);
                    } else if (gatewayStatus == PaymentStatus.FAILED) {
                        eventPublisher.publishPaymentFailed(payment);
                    }
                }
            } catch (Exception e) {
                log.error("Error reconciling payment {}: {}", payment.getId(), e.getMessage());
            }
        }
    }

    private PaymentStatus queryGatewayStatus(Payment payment) {
        return switch (payment.getGateway()) {
            case STRIPE -> stripeClient.getStatus(payment.getGatewayTransactionId());
            case PAYPAL -> payPalClient.getStatus(payment.getGatewayTransactionId());
            default -> payment.getStatus();
        };
    }
}
```

================================================================================
## MODULE 5: Notification Service
================================================================================

```java
package com.example.notification.service;

import org.springframework.stereotype.Service;
import org.springframework.scheduling.annotation.Async;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class NotificationService {

    private final EmailService emailService;
    private final SmsService smsService;
    private final PushNotificationService pushService;
    private final NotificationTemplateService templateService;
    private final UserPreferenceService preferenceService;
    private final NotificationRepository notificationRepository;

    @Async
    public void sendOrderConfirmation(Order order) {
        User user = userService.getUser(order.getCustomerId());
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        
        NotificationTemplate template = templateService.getTemplate("ORDER_CONFIRMATION");
        Map<String, Object> variables = buildOrderVariables(order);
        
        List<NotificationChannel> channels = determineChannels(prefs, NotificationType.ORDER_UPDATE);
        
        for (NotificationChannel channel : channels) {
            try {
                sendViaChannel(channel, user, template, variables);
                
                logNotification(user.getId(), NotificationType.ORDER_UPDATE, channel, "SUCCESS");
            } catch (Exception e) {
                log.error("Failed to send {} notification to user {}: {}", 
                    channel, user.getId(), e.getMessage());
                logNotification(user.getId(), NotificationType.ORDER_UPDATE, channel, "FAILED");
            }
        }
    }

    @Async
    public void sendOrderCancellation(Order order) {
        User user = userService.getUser(order.getCustomerId());
        NotificationTemplate template = templateService.getTemplate("ORDER_CANCELLED");
        
        Map<String, Object> variables = Map.of(
            "orderId", order.getId(),
            "reason", order.getCancellationReason(),
            "refundAmount", order.getTotal()
        );
        
        sendToAllChannels(user, template, variables, NotificationType.ORDER_UPDATE);
    }

    @Async
    public void sendShippingUpdate(Shipment shipment) {
        Order order = orderService.getOrder(shipment.getOrderId());
        User user = userService.getUser(order.getCustomerId());
        
        String templateName = switch (shipment.getStatus()) {
            case SHIPPED -> "ORDER_SHIPPED";
            case OUT_FOR_DELIVERY -> "ORDER_OUT_FOR_DELIVERY";
            case DELIVERED -> "ORDER_DELIVERED";
            default -> null;
        };
        
        if (templateName == null) return;
        
        NotificationTemplate template = templateService.getTemplate(templateName);
        Map<String, Object> variables = Map.of(
            "orderId", order.getId(),
            "trackingNumber", shipment.getTrackingNumber(),
            "carrier", shipment.getCarrier(),
            "estimatedDelivery", shipment.getEstimatedDeliveryDate()
        );
        
        sendToAllChannels(user, template, variables, NotificationType.SHIPPING_UPDATE);
    }

    @Async
    public void sendLowStockAlert(InventoryItem item) {
        List<User> admins = userService.getUsersByRole(Role.INVENTORY_MANAGER);
        NotificationTemplate template = templateService.getTemplate("LOW_STOCK_ALERT");
        
        Map<String, Object> variables = Map.of(
            "productId", item.getProductId(),
            "productName", productService.getProduct(item.getProductId()).getName(),
            "currentStock", item.getQuantityOnHand(),
            "reorderPoint", item.getReorderPoint(),
            "warehouseId", item.getWarehouseId()
        );
        
        for (User admin : admins) {
            sendViaChannel(NotificationChannel.EMAIL, admin, template, variables);
        }
    }

    @Async
    public void sendPasswordResetEmail(User user, String resetToken) {
        NotificationTemplate template = templateService.getTemplate("PASSWORD_RESET");
        
        Map<String, Object> variables = Map.of(
            "userName", user.getName(),
            "resetLink", buildResetLink(resetToken),
            "expiresIn", "24 hours"
        );
        
        emailService.send(
            user.getEmail(),
            template.getSubject(),
            template.renderBody(variables)
        );
        
        logNotification(user.getId(), NotificationType.SECURITY, NotificationChannel.EMAIL, "SUCCESS");
    }

    @Async
    public void sendTwoFactorCode(User user, String code) {
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        
        String message = String.format("Your verification code is: %s. Valid for 10 minutes.", code);
        
        if (prefs.getTwoFactorChannel() == NotificationChannel.SMS) {
            smsService.send(user.getPhoneNumber(), message);
        } else {
            emailService.send(user.getEmail(), "Verification Code", message);
        }
    }

    @Scheduled(cron = "0 0 9 * * *")
    public void sendDailyDigest() {
        List<User> users = userService.getUsersWithDigestEnabled();
        
        for (User user : users) {
            try {
                DigestContent content = buildDigestContent(user);
                
                if (content.hasItems()) {
                    NotificationTemplate template = templateService.getTemplate("DAILY_DIGEST");
                    emailService.send(
                        user.getEmail(),
                        template.getSubject(),
                        template.renderBody(Map.of("digest", content))
                    );
                }
            } catch (Exception e) {
                log.error("Failed to send digest to user {}: {}", user.getId(), e.getMessage());
            }
        }
    }

    private void sendViaChannel(NotificationChannel channel, User user, 
                                 NotificationTemplate template, Map<String, Object> variables) {
        switch (channel) {
            case EMAIL -> emailService.send(
                user.getEmail(),
                template.getSubject(),
                template.renderBody(variables)
            );
            case SMS -> smsService.send(
                user.getPhoneNumber(),
                template.renderSmsBody(variables)
            );
            case PUSH -> pushService.send(
                user.getDeviceTokens(),
                template.getTitle(),
                template.renderPushBody(variables)
            );
        }
    }

    private void sendToAllChannels(User user, NotificationTemplate template, 
                                    Map<String, Object> variables, NotificationType type) {
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        List<NotificationChannel> channels = determineChannels(prefs, type);
        
        for (NotificationChannel channel : channels) {
            try {
                sendViaChannel(channel, user, template, variables);
                logNotification(user.getId(), type, channel, "SUCCESS");
            } catch (Exception e) {
                log.error("Notification failed: {} via {} - {}", type, channel, e.getMessage());
                logNotification(user.getId(), type, channel, "FAILED");
            }
        }
    }

    private List<NotificationChannel> determineChannels(NotificationPreferences prefs, 
                                                         NotificationType type) {
        return prefs.getChannelPreferences().entrySet().stream()
            .filter(e -> e.getValue().contains(type))
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }

    private void logNotification(Long userId, NotificationType type, 
                                  NotificationChannel channel, String status) {
        NotificationLog log = NotificationLog.builder()
            .userId(userId)
            .type(type)
            .channel(channel)
            .status(status)
            .sentAt(Instant.now())
            .build();
        
        notificationRepository.save(log);
    }

    private Map<String, Object> buildOrderVariables(Order order) {
        return Map.of(
            "orderId", order.getId(),
            "items", order.getItems(),
            "subtotal", order.getSubtotal(),
            "tax", order.getTax(),
            "shipping", order.getShippingCost(),
            "total", order.getTotal(),
            "shippingAddress", order.getShippingAddress(),
            "estimatedDelivery", calculateEstimatedDelivery(order)
        );
    }
}
```

================================================================================
## MODULE 6: Reporting and Analytics
================================================================================

```java
package com.example.analytics.service;

import org.springframework.stereotype.Service;
import org.springframework.cache.annotation.Cacheable;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class AnalyticsService {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;
    private final InventoryRepository inventoryRepository;
    private final RevenueCalculator revenueCalculator;

    @Cacheable(value = "salesReport", key = "#startDate + '-' + #endDate")
    public SalesReport generateSalesReport(LocalDate startDate, LocalDate endDate) {
        log.info("Generating sales report for {} to {}", startDate, endDate);
        
        List<Order> orders = orderRepository.findByCreatedAtBetween(
            startDate.atStartOfDay().toInstant(ZoneOffset.UTC),
            endDate.plusDays(1).atStartOfDay().toInstant(ZoneOffset.UTC)
        );
        
        // Filter completed orders only
        List<Order> completedOrders = orders.stream()
            .filter(o -> o.getStatus() == OrderStatus.COMPLETED || 
                        o.getStatus() == OrderStatus.DELIVERED)
            .collect(Collectors.toList());
        
        // Calculate metrics
        BigDecimal totalRevenue = completedOrders.stream()
            .map(Order::getTotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal totalTax = completedOrders.stream()
            .map(Order::getTax)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal averageOrderValue = completedOrders.isEmpty() 
            ? BigDecimal.ZERO 
            : totalRevenue.divide(BigDecimal.valueOf(completedOrders.size()), RoundingMode.HALF_UP);
        
        // Daily breakdown
        Map<LocalDate, DailySales> dailyBreakdown = completedOrders.stream()
            .collect(Collectors.groupingBy(
                o -> o.getCreatedAt().atZone(ZoneOffset.UTC).toLocalDate(),
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    this::calculateDailySales
                )
            ));
        
        // Top products
        List<ProductSales> topProducts = calculateTopProducts(completedOrders, 10);
        
        // Category breakdown
        Map<String, CategorySales> categoryBreakdown = calculateCategoryBreakdown(completedOrders);
        
        return SalesReport.builder()
            .startDate(startDate)
            .endDate(endDate)
            .totalOrders(completedOrders.size())
            .totalRevenue(totalRevenue)
            .totalTax(totalTax)
            .averageOrderValue(averageOrderValue)
            .dailyBreakdown(dailyBreakdown)
            .topProducts(topProducts)
            .categoryBreakdown(categoryBreakdown)
            .generatedAt(Instant.now())
            .build();
    }

    @Cacheable(value = "customerAnalytics", key = "#customerId")
    public CustomerAnalytics getCustomerAnalytics(Long customerId) {
        User customer = userRepository.findById(customerId)
            .orElseThrow(() -> new UserNotFoundException(customerId));
        
        List<Order> orders = orderRepository.findByCustomerId(customerId);
        
        BigDecimal totalSpent = orders.stream()
            .filter(o -> o.getStatus() == OrderStatus.COMPLETED)
            .map(Order::getTotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal averageOrderValue = orders.isEmpty() 
            ? BigDecimal.ZERO 
            : totalSpent.divide(BigDecimal.valueOf(orders.size()), RoundingMode.HALF_UP);
        
        // Purchase frequency
        long daysSinceFirstOrder = orders.isEmpty() ? 0 :
            ChronoUnit.DAYS.between(
                orders.stream().map(Order::getCreatedAt).min(Instant::compareTo).get()
                    .atZone(ZoneOffset.UTC).toLocalDate(),
                LocalDate.now()
            );
        
        double ordersPerMonth = daysSinceFirstOrder > 0 
            ? (double) orders.size() / (daysSinceFirstOrder / 30.0) 
            : 0;
        
        // Favorite categories
        Map<String, Long> categoryPreferences = orders.stream()
            .flatMap(o -> o.getItems().stream())
            .collect(Collectors.groupingBy(
                item -> productRepository.findById(item.getProductId())
                    .map(Product::getCategory)
                    .orElse("Unknown"),
                Collectors.counting()
            ));
        
        // Customer segment
        CustomerSegment segment = determineCustomerSegment(totalSpent, orders.size(), ordersPerMonth);
        
        return CustomerAnalytics.builder()
            .customerId(customerId)
            .customerName(customer.getName())
            .memberSince(customer.getCreatedAt())
            .totalOrders(orders.size())
            .totalSpent(totalSpent)
            .averageOrderValue(averageOrderValue)
            .ordersPerMonth(ordersPerMonth)
            .categoryPreferences(categoryPreferences)
            .segment(segment)
            .lastOrderDate(orders.stream()
                .map(Order::getCreatedAt)
                .max(Instant::compareTo)
                .orElse(null))
            .build();
    }

    public InventoryReport generateInventoryReport() {
        List<InventoryItem> allItems = inventoryRepository.findAll();
        
        // Group by product
        Map<Long, List<InventoryItem>> byProduct = allItems.stream()
            .collect(Collectors.groupingBy(InventoryItem::getProductId));
        
        List<ProductInventoryStatus> productStatuses = byProduct.entrySet().stream()
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                List<InventoryItem> items = entry.getValue();
                
                int totalOnHand = items.stream().mapToInt(InventoryItem::getQuantityOnHand).sum();
                int totalReserved = items.stream().mapToInt(InventoryItem::getQuantityReserved).sum();
                
                InventoryHealthStatus health = determineHealthStatus(items);
                
                return ProductInventoryStatus.builder()
                    .productId(entry.getKey())
                    .productName(product != null ? product.getName() : "Unknown")
                    .totalOnHand(totalOnHand)
                    .totalReserved(totalReserved)
                    .totalAvailable(totalOnHand - totalReserved)
                    .health(health)
                    .warehouseBreakdown(items.stream()
                        .collect(Collectors.toMap(
                            InventoryItem::getWarehouseId,
                            i -> i.getQuantityOnHand() - i.getQuantityReserved()
                        )))
                    .build();
            })
            .sorted(Comparator.comparing(ProductInventoryStatus::getHealth))
            .collect(Collectors.toList());
        
        // Summary metrics
        long criticalItems = productStatuses.stream()
            .filter(p -> p.getHealth() == InventoryHealthStatus.CRITICAL)
            .count();
        
        long lowStockItems = productStatuses.stream()
            .filter(p -> p.getHealth() == InventoryHealthStatus.LOW)
            .count();
        
        BigDecimal totalInventoryValue = productStatuses.stream()
            .map(p -> {
                Product product = productRepository.findById(p.getProductId()).orElse(null);
                return product != null 
                    ? product.getCost().multiply(BigDecimal.valueOf(p.getTotalOnHand()))
                    : BigDecimal.ZERO;
            })
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        return InventoryReport.builder()
            .generatedAt(Instant.now())
            .totalProducts(productStatuses.size())
            .criticalStockItems(criticalItems)
            .lowStockItems(lowStockItems)
            .healthyStockItems(productStatuses.size() - criticalItems - lowStockItems)
            .totalInventoryValue(totalInventoryValue)
            .productStatuses(productStatuses)
            .build();
    }

    @Scheduled(cron = "0 0 1 * * *")
    public void generateDailyMetrics() {
        LocalDate yesterday = LocalDate.now().minusDays(1);
        
        DailyMetrics metrics = DailyMetrics.builder()
            .date(yesterday)
            .salesReport(generateSalesReport(yesterday, yesterday))
            .newCustomers(userRepository.countByCreatedAtBetween(
                yesterday.atStartOfDay().toInstant(ZoneOffset.UTC),
                yesterday.plusDays(1).atStartOfDay().toInstant(ZoneOffset.UTC)
            ))
            .activeUsers(sessionRepository.countDistinctUsersByDate(yesterday))
            .conversionRate(calculateConversionRate(yesterday))
            .build();
        
        metricsRepository.save(metrics);
        
        log.info("Daily metrics generated for {}: {} orders, {} revenue", 
            yesterday, metrics.getSalesReport().getTotalOrders(), 
            metrics.getSalesReport().getTotalRevenue());
    }

    private DailySales calculateDailySales(List<Order> orders) {
        return DailySales.builder()
            .orderCount(orders.size())
            .revenue(orders.stream()
                .map(Order::getTotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add))
            .build();
    }

    private List<ProductSales> calculateTopProducts(List<Order> orders, int limit) {
        Map<Long, ProductSalesAccumulator> accumulator = new HashMap<>();
        
        for (Order order : orders) {
            for (OrderItem item : order.getItems()) {
                accumulator.computeIfAbsent(item.getProductId(), 
                    k -> new ProductSalesAccumulator(item.getProductId(), item.getProductName()))
                    .add(item.getQuantity(), item.getTotalPrice());
            }
        }
        
        return accumulator.values().stream()
            .sorted(Comparator.comparing(ProductSalesAccumulator::getRevenue).reversed())
            .limit(limit)
            .map(ProductSalesAccumulator::toProductSales)
            .collect(Collectors.toList());
    }

    private Map<String, CategorySales> calculateCategoryBreakdown(List<Order> orders) {
        Map<String, CategorySalesAccumulator> accumulator = new HashMap<>();
        
        for (Order order : orders) {
            for (OrderItem item : order.getItems()) {
                String category = productRepository.findById(item.getProductId())
                    .map(Product::getCategory)
                    .orElse("Uncategorized");
                
                accumulator.computeIfAbsent(category, CategorySalesAccumulator::new)
                    .add(item.getQuantity(), item.getTotalPrice());
            }
        }
        
        return accumulator.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().toCategorySales()
            ));
    }

    private CustomerSegment determineCustomerSegment(BigDecimal totalSpent, int orderCount, 
                                                      double ordersPerMonth) {
        if (totalSpent.compareTo(BigDecimal.valueOf(10000)) > 0 && ordersPerMonth > 2) {
            return CustomerSegment.VIP;
        } else if (totalSpent.compareTo(BigDecimal.valueOf(5000)) > 0 && ordersPerMonth > 1) {
            return CustomerSegment.LOYAL;
        } else if (orderCount > 5) {
            return CustomerSegment.REGULAR;
        } else if (orderCount > 0) {
            return CustomerSegment.OCCASIONAL;
        } else {
            return CustomerSegment.NEW;
        }
    }

    private InventoryHealthStatus determineHealthStatus(List<InventoryItem> items) {
        int totalAvailable = items.stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        int avgReorderPoint = (int) items.stream()
            .mapToInt(InventoryItem::getReorderPoint)
            .average()
            .orElse(0);
        
        if (totalAvailable <= 0) {
            return InventoryHealthStatus.OUT_OF_STOCK;
        } else if (totalAvailable <= avgReorderPoint / 2) {
            return InventoryHealthStatus.CRITICAL;
        } else if (totalAvailable <= avgReorderPoint) {
            return InventoryHealthStatus.LOW;
        } else {
            return InventoryHealthStatus.HEALTHY;
        }
    }
}
```

================================================================================
## MODULE 7: Search and Recommendation Engine
================================================================================

```java
package com.example.search.service;

import org.springframework.stereotype.Service;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class SearchAndRecommendationService {

    private final RestHighLevelClient elasticsearchClient;
    private final ProductRepository productRepository;
    private final UserBehaviorRepository behaviorRepository;
    private final SimilarityCalculator similarityCalculator;
    private final MLRecommendationClient mlClient;

    public SearchResults search(SearchRequest request) {
        log.info("Searching for: {} with filters: {}", request.getQuery(), request.getFilters());
        
        SearchSourceBuilder searchBuilder = new SearchSourceBuilder();
        
        // Build query
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // Full-text search on name, description, tags
        if (StringUtils.isNotBlank(request.getQuery())) {
            boolQuery.must(QueryBuilders.multiMatchQuery(request.getQuery())
                .field("name", 3.0f)
                .field("description", 1.0f)
                .field("tags", 2.0f)
                .field("category", 1.5f)
                .fuzziness(Fuzziness.AUTO)
                .prefixLength(2));
        }
        
        // Apply filters
        if (request.getFilters() != null) {
            applyFilters(boolQuery, request.getFilters());
        }
        
        searchBuilder.query(boolQuery);
        
        // Sorting
        if (request.getSortBy() != null) {
            searchBuilder.sort(request.getSortBy(), 
                request.getSortOrder() == SortOrder.DESC ? SortOrder.DESC : SortOrder.ASC);
        } else {
            searchBuilder.sort("_score", SortOrder.DESC);
        }
        
        // Pagination
        searchBuilder.from(request.getPage() * request.getSize());
        searchBuilder.size(request.getSize());
        
        // Execute search
        SearchResponse response = elasticsearchClient.search(
            new SearchRequest("products").source(searchBuilder),
            RequestOptions.DEFAULT
        );
        
        // Map results
        List<ProductSearchResult> results = Arrays.stream(response.getHits().getHits())
            .map(hit -> {
                Map<String, Object> source = hit.getSourceAsMap();
                return ProductSearchResult.builder()
                    .productId(Long.parseLong(hit.getId()))
                    .name((String) source.get("name"))
                    .description((String) source.get("description"))
                    .price(new BigDecimal(source.get("price").toString()))
                    .category((String) source.get("category"))
                    .imageUrl((String) source.get("imageUrl"))
                    .rating((Double) source.get("rating"))
                    .score(hit.getScore())
                    .build();
            })
            .collect(Collectors.toList());
        
        // Get facets/aggregations
        Map<String, List<FacetValue>> facets = extractFacets(response.getAggregations());
        
        // Log search for analytics
        logSearchEvent(request, response.getHits().getTotalHits().value);
        
        return SearchResults.builder()
            .query(request.getQuery())
            .results(results)
            .totalHits(response.getHits().getTotalHits().value)
            .page(request.getPage())
            .size(request.getSize())
            .facets(facets)
            .searchTime(response.getTook().getMillis())
            .build();
    }

    public List<ProductRecommendation> getPersonalizedRecommendations(Long userId, int limit) {
        log.debug("Getting personalized recommendations for user: {}", userId);
        
        // Get user behavior history
        UserBehaviorProfile profile = buildUserProfile(userId);
        
        // Try ML-based recommendations first
        try {
            List<Long> mlRecommendations = mlClient.getRecommendations(userId, limit * 2);
            
            if (!mlRecommendations.isEmpty()) {
                return mlRecommendations.stream()
                    .map(productId -> productRepository.findById(productId).orElse(null))
                    .filter(Objects::nonNull)
                    .filter(p -> !profile.getPurchasedProductIds().contains(p.getId()))
                    .limit(limit)
                    .map(p -> ProductRecommendation.builder()
                        .product(p)
                        .reason("Based on your shopping history")
                        .score(0.9)
                        .build())
                    .collect(Collectors.toList());
            }
        } catch (Exception e) {
            log.warn("ML recommendation service unavailable, falling back to rule-based", e);
        }
        
        // Fallback: Rule-based recommendations
        return getRuleBasedRecommendations(profile, limit);
    }

    public List<ProductRecommendation> getSimilarProducts(Long productId, int limit) {
        Product baseProduct = productRepository.findById(productId)
            .orElseThrow(() -> new ProductNotFoundException(productId));
        
        // Get products in same category
        List<Product> categoryProducts = productRepository.findByCategory(baseProduct.getCategory());
        
        // Calculate similarity scores
        return categoryProducts.stream()
            .filter(p -> !p.getId().equals(productId))
            .map(p -> {
                double similarity = similarityCalculator.calculate(baseProduct, p);
                return ProductRecommendation.builder()
                    .product(p)
                    .reason("Similar to " + baseProduct.getName())
                    .score(similarity)
                    .build();
            })
            .filter(r -> r.getScore() > 0.3)
            .sorted(Comparator.comparing(ProductRecommendation::getScore).reversed())
            .limit(limit)
            .collect(Collectors.toList());
    }

    public List<ProductRecommendation> getFrequentlyBoughtTogether(Long productId, int limit) {
        // Find orders containing this product
        List<Order> ordersWithProduct = orderRepository.findByItemsProductId(productId);
        
        // Count co-occurrence of other products
        Map<Long, Long> coOccurrence = ordersWithProduct.stream()
            .flatMap(o -> o.getItems().stream())
            .map(OrderItem::getProductId)
            .filter(id -> !id.equals(productId))
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        
        // Get top co-occurring products
        return coOccurrence.entrySet().stream()
            .sorted(Map.Entry.<Long, Long>comparingByValue().reversed())
            .limit(limit)
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                if (product == null) return null;
                
                double score = (double) entry.getValue() / ordersWithProduct.size();
                return ProductRecommendation.builder()
                    .product(product)
                    .reason("Frequently bought together")
                    .score(score)
                    .build();
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }

    public List<ProductRecommendation> getTrendingProducts(int limit) {
        LocalDate weekAgo = LocalDate.now().minusDays(7);
        
        // Get recent orders
        List<Order> recentOrders = orderRepository.findByCreatedAtAfter(
            weekAgo.atStartOfDay().toInstant(ZoneOffset.UTC)
        );
        
        // Count product sales with recency weighting
        Map<Long, Double> trendingScores = new HashMap<>();
        
        for (Order order : recentOrders) {
            long daysAgo = ChronoUnit.DAYS.between(
                order.getCreatedAt().atZone(ZoneOffset.UTC).toLocalDate(),
                LocalDate.now()
            );
            double recencyWeight = 1.0 / (1.0 + daysAgo * 0.1);
            
            for (OrderItem item : order.getItems()) {
                trendingScores.merge(item.getProductId(), 
                    item.getQuantity() * recencyWeight, 
                    Double::sum);
            }
        }
        
        // Normalize and return top trending
        double maxScore = trendingScores.values().stream()
            .max(Double::compareTo)
            .orElse(1.0);
        
        return trendingScores.entrySet().stream()
            .sorted(Map.Entry.<Long, Double>comparingByValue().reversed())
            .limit(limit)
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                if (product == null) return null;
                
                return ProductRecommendation.builder()
                    .product(product)
                    .reason("Trending this week")
                    .score(entry.getValue() / maxScore)
                    .build();
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }

    @Async
    public void trackUserBehavior(Long userId, BehaviorEvent event) {
        UserBehavior behavior = UserBehavior.builder()
            .userId(userId)
            .eventType(event.getType())
            .productId(event.getProductId())
            .searchQuery(event.getSearchQuery())
            .timestamp(Instant.now())
            .sessionId(event.getSessionId())
            .metadata(event.getMetadata())
            .build();
        
        behaviorRepository.save(behavior);
        
        // Update real-time recommendations cache if significant event
        if (event.getType() == BehaviorType.PURCHASE || 
            event.getType() == BehaviorType.ADD_TO_CART) {
            recommendationCache.invalidate(userId);
        }
    }

    private void applyFilters(BoolQueryBuilder boolQuery, SearchFilters filters) {
        if (filters.getCategories() != null && !filters.getCategories().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("category", filters.getCategories()));
        }
        
        if (filters.getMinPrice() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("price").gte(filters.getMinPrice()));
        }
        
        if (filters.getMaxPrice() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("price").lte(filters.getMaxPrice()));
        }
        
        if (filters.getMinRating() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("rating").gte(filters.getMinRating()));
        }
        
        if (filters.getInStock() != null && filters.getInStock()) {
            boolQuery.filter(QueryBuilders.termQuery("inStock", true));
        }
        
        if (filters.getBrands() != null && !filters.getBrands().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("brand", filters.getBrands()));
        }
        
        if (filters.getTags() != null && !filters.getTags().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("tags", filters.getTags()));
        }
    }

    private UserBehaviorProfile buildUserProfile(Long userId) {
        List<UserBehavior> behaviors = behaviorRepository.findByUserIdOrderByTimestampDesc(
            userId, PageRequest.of(0, 1000)
        );
        
        Set<Long> purchasedProducts = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.PURCHASE)
            .map(UserBehavior::getProductId)
            .collect(Collectors.toSet());
        
        Set<Long> viewedProducts = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.VIEW)
            .map(UserBehavior::getProductId)
            .collect(Collectors.toSet());
        
        Map<String, Long> categoryInterests = behaviors.stream()
            .filter(b -> b.getProductId() != null)
            .map(b -> productRepository.findById(b.getProductId())
                .map(Product::getCategory)
                .orElse(null))
            .filter(Objects::nonNull)
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        
        List<String> recentSearches = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.SEARCH)
            .map(UserBehavior::getSearchQuery)
            .filter(Objects::nonNull)
            .limit(20)
            .collect(Collectors.toList());
        
        return UserBehaviorProfile.builder()
            .userId(userId)
            .purchasedProductIds(purchasedProducts)
            .viewedProductIds(viewedProducts)
            .categoryInterests(categoryInterests)
            .recentSearches(recentSearches)
            .build();
    }

    private List<ProductRecommendation> getRuleBasedRecommendations(UserBehaviorProfile profile, 
                                                                      int limit) {
        List<ProductRecommendation> recommendations = new ArrayList<>();
        
        // 1. Products from favorite categories
        String topCategory = profile.getCategoryInterests().entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
        
        if (topCategory != null) {
            productRepository.findByCategoryAndIdNotIn(topCategory, profile.getPurchasedProductIds())
                .stream()
                .limit(limit / 2)
                .forEach(p -> recommendations.add(ProductRecommendation.builder()
                    .product(p)
                    .reason("Based on your interest in " + topCategory)
                    .score(0.7)
                    .build()));
        }
        
        // 2. Highly rated products user hasn't purchased
        productRepository.findTopRatedNotPurchased(profile.getPurchasedProductIds(), limit / 2)
            .forEach(p -> recommendations.add(ProductRecommendation.builder()
                .product(p)
                .reason("Top rated product")
                .score(0.6)
                .build()));
        
        return recommendations.stream()
            .distinct()
            .limit(limit)
            .collect(Collectors.toList());
    }
}
```

================================================================================
## END OF FILE - REPEAT SECTION FOR SIZE
================================================================================
# Large Codebase Simulation File
# This file simulates a large codebase for context overflow testing
# Generated for focus-task plugin testing

================================================================================
## MODULE 1: Authentication Service
================================================================================

```java
package com.example.auth.service;

import org.springframework.stereotype.Service;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class AuthenticationService {

    private final UserRepository userRepository;
    private final TokenService tokenService;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AuditLogService auditLogService;

    public AuthResponse authenticate(AuthRequest request) {
        log.info("Authentication attempt for user: {}", request.getUsername());
        
        User user = userRepository.findByUsername(request.getUsername())
            .orElseThrow(() -> new AuthenticationException("User not found"));
        
        if (!passwordEncoder.matches(request.getPassword(), user.getPasswordHash())) {
            auditLogService.logFailedLogin(user.getId(), request.getIpAddress());
            throw new AuthenticationException("Invalid credentials");
        }
        
        if (!user.isEnabled()) {
            throw new AuthenticationException("Account disabled");
        }
        
        String accessToken = tokenService.generateAccessToken(user);
        String refreshToken = tokenService.generateRefreshToken(user);
        
        auditLogService.logSuccessfulLogin(user.getId(), request.getIpAddress());
        
        return AuthResponse.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .expiresIn(tokenService.getAccessTokenExpiration())
            .tokenType("Bearer")
            .build();
    }

    public AuthResponse refreshToken(String refreshToken) {
        TokenClaims claims = tokenService.validateRefreshToken(refreshToken);
        
        User user = userRepository.findById(claims.getUserId())
            .orElseThrow(() -> new AuthenticationException("User not found"));
        
        String newAccessToken = tokenService.generateAccessToken(user);
        
        return AuthResponse.builder()
            .accessToken(newAccessToken)
            .refreshToken(refreshToken)
            .expiresIn(tokenService.getAccessTokenExpiration())
            .tokenType("Bearer")
            .build();
    }

    public void logout(String accessToken) {
        tokenService.revokeToken(accessToken);
        log.info("User logged out successfully");
    }

    public void changePassword(Long userId, ChangePasswordRequest request) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException(userId));
        
        if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPasswordHash())) {
            throw new AuthenticationException("Current password is incorrect");
        }
        
        validatePasswordStrength(request.getNewPassword());
        
        user.setPasswordHash(passwordEncoder.encode(request.getNewPassword()));
        user.setPasswordChangedAt(Instant.now());
        userRepository.save(user);
        
        tokenService.revokeAllUserTokens(userId);
        auditLogService.logPasswordChange(userId);
    }

    private void validatePasswordStrength(String password) {
        if (password.length() < 12) {
            throw new ValidationException("Password must be at least 12 characters");
        }
        if (!password.matches(".*[A-Z].*")) {
            throw new ValidationException("Password must contain uppercase letter");
        }
        if (!password.matches(".*[a-z].*")) {
            throw new ValidationException("Password must contain lowercase letter");
        }
        if (!password.matches(".*\\d.*")) {
            throw new ValidationException("Password must contain digit");
        }
        if (!password.matches(".*[!@#$%^&*()].*")) {
            throw new ValidationException("Password must contain special character");
        }
    }
}
```

================================================================================
## MODULE 2: Order Processing Service
================================================================================

```java
package com.example.orders.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class OrderProcessingService {

    private final OrderRepository orderRepository;
    private final ProductService productService;
    private final InventoryService inventoryService;
    private final PaymentService paymentService;
    private final NotificationService notificationService;
    private final ShippingService shippingService;
    private final TaxCalculationService taxService;
    private final DiscountService discountService;

    @Transactional
    public OrderResponse createOrder(CreateOrderRequest request) {
        log.info("Creating order for customer: {}", request.getCustomerId());
        
        // Validate products availability
        List<OrderItem> items = request.getItems().stream()
            .map(this::validateAndCreateOrderItem)
            .collect(Collectors.toList());
        
        // Calculate totals
        BigDecimal subtotal = calculateSubtotal(items);
        BigDecimal discount = discountService.calculateDiscount(request.getPromoCode(), subtotal);
        BigDecimal tax = taxService.calculateTax(subtotal.subtract(discount), request.getShippingAddress());
        BigDecimal shippingCost = shippingService.calculateShippingCost(items, request.getShippingAddress());
        BigDecimal total = subtotal.subtract(discount).add(tax).add(shippingCost);
        
        // Create order
        Order order = Order.builder()
            .customerId(request.getCustomerId())
            .items(items)
            .subtotal(subtotal)
            .discount(discount)
            .tax(tax)
            .shippingCost(shippingCost)
            .total(total)
            .status(OrderStatus.PENDING)
            .shippingAddress(request.getShippingAddress())
            .billingAddress(request.getBillingAddress())
            .createdAt(Instant.now())
            .build();
        
        order = orderRepository.save(order);
        
        // Reserve inventory
        items.forEach(item -> inventoryService.reserveStock(item.getProductId(), item.getQuantity()));
        
        log.info("Order {} created successfully with total: {}", order.getId(), total);
        
        return mapToResponse(order);
    }

    @Transactional
    public OrderResponse processPayment(Long orderId, PaymentRequest paymentRequest) {
        Order order = getOrderOrThrow(orderId);
        
        if (order.getStatus() != OrderStatus.PENDING) {
            throw new OrderProcessingException("Order is not in pending status");
        }
        
        PaymentResult result = paymentService.processPayment(
            paymentRequest.getPaymentMethodId(),
            order.getTotal(),
            order.getId().toString()
        );
        
        if (result.isSuccessful()) {
            order.setStatus(OrderStatus.PAID);
            order.setPaymentId(result.getTransactionId());
            order.setPaidAt(Instant.now());
            
            // Commit inventory reservation
            order.getItems().forEach(item -> 
                inventoryService.commitReservation(item.getProductId(), item.getQuantity()));
            
            // Trigger fulfillment
            shippingService.createShipment(order);
            
            // Send confirmation
            notificationService.sendOrderConfirmation(order);
            
            log.info("Payment processed successfully for order: {}", orderId);
        } else {
            order.setStatus(OrderStatus.PAYMENT_FAILED);
            order.setPaymentError(result.getErrorMessage());
            
            // Release inventory reservation
            order.getItems().forEach(item -> 
                inventoryService.releaseReservation(item.getProductId(), item.getQuantity()));
            
            log.warn("Payment failed for order: {} - {}", orderId, result.getErrorMessage());
        }
        
        orderRepository.save(order);
        return mapToResponse(order);
    }

    @Transactional
    public OrderResponse cancelOrder(Long orderId, String reason) {
        Order order = getOrderOrThrow(orderId);
        
        if (!order.getStatus().isCancellable()) {
            throw new OrderProcessingException("Order cannot be cancelled in current status");
        }
        
        // Refund if already paid
        if (order.getPaymentId() != null) {
            paymentService.refund(order.getPaymentId(), order.getTotal());
        }
        
        // Release inventory
        order.getItems().forEach(item -> 
            inventoryService.releaseStock(item.getProductId(), item.getQuantity()));
        
        order.setStatus(OrderStatus.CANCELLED);
        order.setCancellationReason(reason);
        order.setCancelledAt(Instant.now());
        
        orderRepository.save(order);
        
        notificationService.sendOrderCancellation(order);
        
        log.info("Order {} cancelled: {}", orderId, reason);
        
        return mapToResponse(order);
    }

    public List<OrderResponse> getCustomerOrders(Long customerId, Pageable pageable) {
        return orderRepository.findByCustomerId(customerId, pageable)
            .stream()
            .map(this::mapToResponse)
            .collect(Collectors.toList());
    }

    public OrderResponse getOrderDetails(Long orderId) {
        return mapToResponse(getOrderOrThrow(orderId));
    }

    private OrderItem validateAndCreateOrderItem(OrderItemRequest request) {
        Product product = productService.getProduct(request.getProductId());
        
        if (!product.isAvailable()) {
            throw new ProductNotAvailableException(product.getId());
        }
        
        if (!inventoryService.hasStock(product.getId(), request.getQuantity())) {
            throw new InsufficientStockException(product.getId(), request.getQuantity());
        }
        
        return OrderItem.builder()
            .productId(product.getId())
            .productName(product.getName())
            .quantity(request.getQuantity())
            .unitPrice(product.getPrice())
            .totalPrice(product.getPrice().multiply(BigDecimal.valueOf(request.getQuantity())))
            .build();
    }

    private BigDecimal calculateSubtotal(List<OrderItem> items) {
        return items.stream()
            .map(OrderItem::getTotalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    private Order getOrderOrThrow(Long orderId) {
        return orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
    }

    private OrderResponse mapToResponse(Order order) {
        return OrderResponse.builder()
            .id(order.getId())
            .customerId(order.getCustomerId())
            .items(order.getItems().stream()
                .map(this::mapItemToResponse)
                .collect(Collectors.toList()))
            .subtotal(order.getSubtotal())
            .discount(order.getDiscount())
            .tax(order.getTax())
            .shippingCost(order.getShippingCost())
            .total(order.getTotal())
            .status(order.getStatus())
            .createdAt(order.getCreatedAt())
            .build();
    }

    private OrderItemResponse mapItemToResponse(OrderItem item) {
        return OrderItemResponse.builder()
            .productId(item.getProductId())
            .productName(item.getProductName())
            .quantity(item.getQuantity())
            .unitPrice(item.getUnitPrice())
            .totalPrice(item.getTotalPrice())
            .build();
    }
}
```

================================================================================
## MODULE 3: Inventory Management System
================================================================================

```java
package com.example.inventory.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
@Slf4j
@RequiredArgsConstructor
public class InventoryManagementService {

    private final InventoryRepository inventoryRepository;
    private final WarehouseRepository warehouseRepository;
    private final ReorderService reorderService;
    private final NotificationService notificationService;
    private final AuditService auditService;
    
    private final Map<String, ReservationLock> reservationLocks = new ConcurrentHashMap<>();

    @Transactional
    public InventoryItem addStock(Long productId, Long warehouseId, int quantity, String reason) {
        log.info("Adding {} units of product {} to warehouse {}", quantity, productId, warehouseId);
        
        InventoryItem item = getOrCreateInventoryItem(productId, warehouseId);
        int previousQuantity = item.getQuantityOnHand();
        
        item.setQuantityOnHand(item.getQuantityOnHand() + quantity);
        item.setLastRestockedAt(Instant.now());
        
        inventoryRepository.save(item);
        
        auditService.logInventoryChange(
            productId, warehouseId, previousQuantity, item.getQuantityOnHand(), reason
        );
        
        checkReorderThreshold(item);
        
        return item;
    }

    @Transactional
    public synchronized boolean reserveStock(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdOrderByQuantityDesc(productId);
        
        int totalAvailable = items.stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        if (totalAvailable < quantity) {
            log.warn("Insufficient stock for product {}: requested {}, available {}", 
                productId, quantity, totalAvailable);
            return false;
        }
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int available = item.getQuantityOnHand() - item.getQuantityReserved();
            int toReserve = Math.min(available, remaining);
            
            if (toReserve > 0) {
                item.setQuantityReserved(item.getQuantityReserved() + toReserve);
                inventoryRepository.save(item);
                remaining -= toReserve;
                
                log.debug("Reserved {} units from warehouse {} for product {}", 
                    toReserve, item.getWarehouseId(), productId);
            }
        }
        
        return true;
    }

    @Transactional
    public void commitReservation(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdAndQuantityReservedGreaterThan(productId, 0);
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int toCommit = Math.min(item.getQuantityReserved(), remaining);
            
            item.setQuantityOnHand(item.getQuantityOnHand() - toCommit);
            item.setQuantityReserved(item.getQuantityReserved() - toCommit);
            inventoryRepository.save(item);
            
            remaining -= toCommit;
            
            checkReorderThreshold(item);
        }
        
        log.info("Committed reservation of {} units for product {}", quantity, productId);
    }

    @Transactional
    public void releaseReservation(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdAndQuantityReservedGreaterThan(productId, 0);
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int toRelease = Math.min(item.getQuantityReserved(), remaining);
            item.setQuantityReserved(item.getQuantityReserved() - toRelease);
            inventoryRepository.save(item);
            
            remaining -= toRelease;
        }
        
        log.info("Released reservation of {} units for product {}", quantity, productId);
    }

    public boolean hasStock(Long productId, int quantity) {
        int available = inventoryRepository.findByProductId(productId).stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        return available >= quantity;
    }

    public InventoryStatus getInventoryStatus(Long productId) {
        List<InventoryItem> items = inventoryRepository.findByProductId(productId);
        
        int totalOnHand = items.stream().mapToInt(InventoryItem::getQuantityOnHand).sum();
        int totalReserved = items.stream().mapToInt(InventoryItem::getQuantityReserved).sum();
        int totalAvailable = totalOnHand - totalReserved;
        
        return InventoryStatus.builder()
            .productId(productId)
            .totalOnHand(totalOnHand)
            .totalReserved(totalReserved)
            .totalAvailable(totalAvailable)
            .warehouseBreakdown(items.stream()
                .collect(Collectors.toMap(
                    InventoryItem::getWarehouseId,
                    i -> new WarehouseStock(i.getQuantityOnHand(), i.getQuantityReserved())
                )))
            .build();
    }

    @Scheduled(cron = "0 0 * * * *")
    public void checkLowStockLevels() {
        log.info("Running scheduled low stock check");
        
        List<InventoryItem> lowStockItems = inventoryRepository.findItemsBelowReorderPoint();
        
        for (InventoryItem item : lowStockItems) {
            if (!reorderService.hasPendingReorder(item.getProductId())) {
                ReorderRequest request = calculateReorderQuantity(item);
                reorderService.createReorderRequest(request);
                
                notificationService.sendLowStockAlert(item);
                
                log.info("Created reorder request for product {} at warehouse {}", 
                    item.getProductId(), item.getWarehouseId());
            }
        }
    }

    @Transactional
    public void transferStock(Long productId, Long fromWarehouse, Long toWarehouse, int quantity) {
        InventoryItem source = inventoryRepository.findByProductIdAndWarehouseId(productId, fromWarehouse)
            .orElseThrow(() -> new InventoryNotFoundException(productId, fromWarehouse));
        
        int available = source.getQuantityOnHand() - source.getQuantityReserved();
        if (available < quantity) {
            throw new InsufficientStockException(productId, quantity);
        }
        
        source.setQuantityOnHand(source.getQuantityOnHand() - quantity);
        inventoryRepository.save(source);
        
        InventoryItem destination = getOrCreateInventoryItem(productId, toWarehouse);
        destination.setQuantityOnHand(destination.getQuantityOnHand() + quantity);
        inventoryRepository.save(destination);
        
        auditService.logStockTransfer(productId, fromWarehouse, toWarehouse, quantity);
        
        log.info("Transferred {} units of product {} from warehouse {} to {}", 
            quantity, productId, fromWarehouse, toWarehouse);
    }

    private InventoryItem getOrCreateInventoryItem(Long productId, Long warehouseId) {
        return inventoryRepository.findByProductIdAndWarehouseId(productId, warehouseId)
            .orElseGet(() -> {
                Warehouse warehouse = warehouseRepository.findById(warehouseId)
                    .orElseThrow(() -> new WarehouseNotFoundException(warehouseId));
                
                return InventoryItem.builder()
                    .productId(productId)
                    .warehouseId(warehouseId)
                    .quantityOnHand(0)
                    .quantityReserved(0)
                    .reorderPoint(warehouse.getDefaultReorderPoint())
                    .reorderQuantity(warehouse.getDefaultReorderQuantity())
                    .build();
            });
    }

    private void checkReorderThreshold(InventoryItem item) {
        int available = item.getQuantityOnHand() - item.getQuantityReserved();
        
        if (available <= item.getReorderPoint()) {
            log.info("Product {} at warehouse {} below reorder point: {} <= {}", 
                item.getProductId(), item.getWarehouseId(), available, item.getReorderPoint());
            
            if (!reorderService.hasPendingReorder(item.getProductId())) {
                ReorderRequest request = calculateReorderQuantity(item);
                reorderService.createReorderRequest(request);
            }
        }
    }

    private ReorderRequest calculateReorderQuantity(InventoryItem item) {
        // Calculate based on historical demand and lead time
        int suggestedQuantity = Math.max(
            item.getReorderQuantity(),
            (int) (demandForecastService.getAverageDailyDemand(item.getProductId()) * 
                   supplierService.getLeadTimeDays(item.getProductId()) * 1.5)
        );
        
        return ReorderRequest.builder()
            .productId(item.getProductId())
            .warehouseId(item.getWarehouseId())
            .quantity(suggestedQuantity)
            .priority(available <= item.getReorderPoint() / 2 ? Priority.HIGH : Priority.NORMAL)
            .build();
    }
}
```

================================================================================
## MODULE 4: Payment Processing Gateway
================================================================================

```java
package com.example.payment.service;

import org.springframework.stereotype.Service;
import org.springframework.retry.annotation.Retryable;
import org.springframework.retry.annotation.Backoff;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.math.BigDecimal;
import java.util.UUID;

@Service
@Slf4j
@RequiredArgsConstructor
public class PaymentGatewayService {

    private final StripeClient stripeClient;
    private final PayPalClient payPalClient;
    private final PaymentRepository paymentRepository;
    private final FraudDetectionService fraudDetectionService;
    private final CurrencyConversionService currencyService;
    private final PaymentEventPublisher eventPublisher;

    @Retryable(
        value = {PaymentGatewayException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public PaymentResult processPayment(PaymentRequest request) {
        log.info("Processing payment of {} {} for order {}", 
            request.getAmount(), request.getCurrency(), request.getOrderId());
        
        // Fraud check
        FraudCheckResult fraudResult = fraudDetectionService.checkTransaction(request);
        if (fraudResult.isBlocked()) {
            log.warn("Payment blocked by fraud detection: {}", fraudResult.getReason());
            return PaymentResult.failed(fraudResult.getReason());
        }
        
        // Create payment record
        Payment payment = Payment.builder()
            .id(UUID.randomUUID().toString())
            .orderId(request.getOrderId())
            .amount(request.getAmount())
            .currency(request.getCurrency())
            .paymentMethodId(request.getPaymentMethodId())
            .status(PaymentStatus.PROCESSING)
            .createdAt(Instant.now())
            .build();
        
        paymentRepository.save(payment);
        
        try {
            PaymentResult result = processWithGateway(request, payment);
            
            if (result.isSuccessful()) {
                payment.setStatus(PaymentStatus.COMPLETED);
                payment.setGatewayTransactionId(result.getTransactionId());
                payment.setCompletedAt(Instant.now());
                
                eventPublisher.publishPaymentCompleted(payment);
            } else {
                payment.setStatus(PaymentStatus.FAILED);
                payment.setErrorMessage(result.getErrorMessage());
                
                eventPublisher.publishPaymentFailed(payment);
            }
            
            paymentRepository.save(payment);
            return result;
            
        } catch (Exception e) {
            log.error("Payment processing error for order {}: {}", request.getOrderId(), e.getMessage());
            
            payment.setStatus(PaymentStatus.ERROR);
            payment.setErrorMessage(e.getMessage());
            paymentRepository.save(payment);
            
            throw new PaymentProcessingException("Payment processing failed", e);
        }
    }

    @Retryable(
        value = {RefundException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 2000, multiplier = 2)
    )
    public RefundResult refund(String paymentId, BigDecimal amount, String reason) {
        Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow(() -> new PaymentNotFoundException(paymentId));
        
        if (payment.getStatus() != PaymentStatus.COMPLETED) {
            throw new RefundException("Cannot refund payment in status: " + payment.getStatus());
        }
        
        BigDecimal refundedAmount = payment.getRefunds().stream()
            .map(Refund::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal maxRefundable = payment.getAmount().subtract(refundedAmount);
        if (amount.compareTo(maxRefundable) > 0) {
            throw new RefundException("Refund amount exceeds available: " + maxRefundable);
        }
        
        log.info("Processing refund of {} for payment {}", amount, paymentId);
        
        RefundResult result = switch (payment.getGateway()) {
            case STRIPE -> stripeClient.refund(payment.getGatewayTransactionId(), amount);
            case PAYPAL -> payPalClient.refund(payment.getGatewayTransactionId(), amount);
            default -> throw new UnsupportedGatewayException(payment.getGateway());
        };
        
        if (result.isSuccessful()) {
            Refund refund = Refund.builder()
                .id(UUID.randomUUID().toString())
                .paymentId(paymentId)
                .amount(amount)
                .reason(reason)
                .gatewayRefundId(result.getRefundId())
                .createdAt(Instant.now())
                .build();
            
            payment.getRefunds().add(refund);
            
            if (payment.getAmount().equals(refundedAmount.add(amount))) {
                payment.setStatus(PaymentStatus.FULLY_REFUNDED);
            } else {
                payment.setStatus(PaymentStatus.PARTIALLY_REFUNDED);
            }
            
            paymentRepository.save(payment);
            eventPublisher.publishRefundCompleted(refund);
        }
        
        return result;
    }

    public PaymentStatus getPaymentStatus(String paymentId) {
        return paymentRepository.findById(paymentId)
            .map(Payment::getStatus)
            .orElseThrow(() -> new PaymentNotFoundException(paymentId));
    }

    public List<Payment> getPaymentHistory(String orderId) {
        return paymentRepository.findByOrderId(orderId);
    }

    private PaymentResult processWithGateway(PaymentRequest request, Payment payment) {
        PaymentMethod method = paymentMethodRepository.findById(request.getPaymentMethodId())
            .orElseThrow(() -> new PaymentMethodNotFoundException(request.getPaymentMethodId()));
        
        // Currency conversion if needed
        BigDecimal processAmount = request.getAmount();
        String processCurrency = request.getCurrency();
        
        if (!method.getSupportedCurrencies().contains(request.getCurrency())) {
            CurrencyConversion conversion = currencyService.convert(
                request.getAmount(), 
                request.getCurrency(), 
                method.getDefaultCurrency()
            );
            processAmount = conversion.getConvertedAmount();
            processCurrency = conversion.getTargetCurrency();
            payment.setConversionRate(conversion.getRate());
        }
        
        PaymentGateway gateway = method.getGateway();
        payment.setGateway(gateway);
        
        return switch (gateway) {
            case STRIPE -> stripeClient.charge(
                method.getGatewayToken(),
                processAmount,
                processCurrency,
                payment.getId()
            );
            case PAYPAL -> payPalClient.charge(
                method.getGatewayToken(),
                processAmount,
                processCurrency,
                payment.getId()
            );
            default -> throw new UnsupportedGatewayException(gateway);
        };
    }

    @Scheduled(fixedRate = 60000)
    public void reconcilePendingPayments() {
        List<Payment> pendingPayments = paymentRepository.findByStatusAndCreatedAtBefore(
            PaymentStatus.PROCESSING,
            Instant.now().minus(Duration.ofMinutes(15))
        );
        
        for (Payment payment : pendingPayments) {
            try {
                PaymentStatus gatewayStatus = queryGatewayStatus(payment);
                
                if (gatewayStatus != payment.getStatus()) {
                    log.info("Reconciling payment {}: {} -> {}", 
                        payment.getId(), payment.getStatus(), gatewayStatus);
                    
                    payment.setStatus(gatewayStatus);
                    paymentRepository.save(payment);
                    
                    if (gatewayStatus == PaymentStatus.COMPLETED) {
                        eventPublisher.publishPaymentCompleted(payment);
                    } else if (gatewayStatus == PaymentStatus.FAILED) {
                        eventPublisher.publishPaymentFailed(payment);
                    }
                }
            } catch (Exception e) {
                log.error("Error reconciling payment {}: {}", payment.getId(), e.getMessage());
            }
        }
    }

    private PaymentStatus queryGatewayStatus(Payment payment) {
        return switch (payment.getGateway()) {
            case STRIPE -> stripeClient.getStatus(payment.getGatewayTransactionId());
            case PAYPAL -> payPalClient.getStatus(payment.getGatewayTransactionId());
            default -> payment.getStatus();
        };
    }
}
```

================================================================================
## MODULE 5: Notification Service
================================================================================

```java
package com.example.notification.service;

import org.springframework.stereotype.Service;
import org.springframework.scheduling.annotation.Async;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class NotificationService {

    private final EmailService emailService;
    private final SmsService smsService;
    private final PushNotificationService pushService;
    private final NotificationTemplateService templateService;
    private final UserPreferenceService preferenceService;
    private final NotificationRepository notificationRepository;

    @Async
    public void sendOrderConfirmation(Order order) {
        User user = userService.getUser(order.getCustomerId());
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        
        NotificationTemplate template = templateService.getTemplate("ORDER_CONFIRMATION");
        Map<String, Object> variables = buildOrderVariables(order);
        
        List<NotificationChannel> channels = determineChannels(prefs, NotificationType.ORDER_UPDATE);
        
        for (NotificationChannel channel : channels) {
            try {
                sendViaChannel(channel, user, template, variables);
                
                logNotification(user.getId(), NotificationType.ORDER_UPDATE, channel, "SUCCESS");
            } catch (Exception e) {
                log.error("Failed to send {} notification to user {}: {}", 
                    channel, user.getId(), e.getMessage());
                logNotification(user.getId(), NotificationType.ORDER_UPDATE, channel, "FAILED");
            }
        }
    }

    @Async
    public void sendOrderCancellation(Order order) {
        User user = userService.getUser(order.getCustomerId());
        NotificationTemplate template = templateService.getTemplate("ORDER_CANCELLED");
        
        Map<String, Object> variables = Map.of(
            "orderId", order.getId(),
            "reason", order.getCancellationReason(),
            "refundAmount", order.getTotal()
        );
        
        sendToAllChannels(user, template, variables, NotificationType.ORDER_UPDATE);
    }

    @Async
    public void sendShippingUpdate(Shipment shipment) {
        Order order = orderService.getOrder(shipment.getOrderId());
        User user = userService.getUser(order.getCustomerId());
        
        String templateName = switch (shipment.getStatus()) {
            case SHIPPED -> "ORDER_SHIPPED";
            case OUT_FOR_DELIVERY -> "ORDER_OUT_FOR_DELIVERY";
            case DELIVERED -> "ORDER_DELIVERED";
            default -> null;
        };
        
        if (templateName == null) return;
        
        NotificationTemplate template = templateService.getTemplate(templateName);
        Map<String, Object> variables = Map.of(
            "orderId", order.getId(),
            "trackingNumber", shipment.getTrackingNumber(),
            "carrier", shipment.getCarrier(),
            "estimatedDelivery", shipment.getEstimatedDeliveryDate()
        );
        
        sendToAllChannels(user, template, variables, NotificationType.SHIPPING_UPDATE);
    }

    @Async
    public void sendLowStockAlert(InventoryItem item) {
        List<User> admins = userService.getUsersByRole(Role.INVENTORY_MANAGER);
        NotificationTemplate template = templateService.getTemplate("LOW_STOCK_ALERT");
        
        Map<String, Object> variables = Map.of(
            "productId", item.getProductId(),
            "productName", productService.getProduct(item.getProductId()).getName(),
            "currentStock", item.getQuantityOnHand(),
            "reorderPoint", item.getReorderPoint(),
            "warehouseId", item.getWarehouseId()
        );
        
        for (User admin : admins) {
            sendViaChannel(NotificationChannel.EMAIL, admin, template, variables);
        }
    }

    @Async
    public void sendPasswordResetEmail(User user, String resetToken) {
        NotificationTemplate template = templateService.getTemplate("PASSWORD_RESET");
        
        Map<String, Object> variables = Map.of(
            "userName", user.getName(),
            "resetLink", buildResetLink(resetToken),
            "expiresIn", "24 hours"
        );
        
        emailService.send(
            user.getEmail(),
            template.getSubject(),
            template.renderBody(variables)
        );
        
        logNotification(user.getId(), NotificationType.SECURITY, NotificationChannel.EMAIL, "SUCCESS");
    }

    @Async
    public void sendTwoFactorCode(User user, String code) {
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        
        String message = String.format("Your verification code is: %s. Valid for 10 minutes.", code);
        
        if (prefs.getTwoFactorChannel() == NotificationChannel.SMS) {
            smsService.send(user.getPhoneNumber(), message);
        } else {
            emailService.send(user.getEmail(), "Verification Code", message);
        }
    }

    @Scheduled(cron = "0 0 9 * * *")
    public void sendDailyDigest() {
        List<User> users = userService.getUsersWithDigestEnabled();
        
        for (User user : users) {
            try {
                DigestContent content = buildDigestContent(user);
                
                if (content.hasItems()) {
                    NotificationTemplate template = templateService.getTemplate("DAILY_DIGEST");
                    emailService.send(
                        user.getEmail(),
                        template.getSubject(),
                        template.renderBody(Map.of("digest", content))
                    );
                }
            } catch (Exception e) {
                log.error("Failed to send digest to user {}: {}", user.getId(), e.getMessage());
            }
        }
    }

    private void sendViaChannel(NotificationChannel channel, User user, 
                                 NotificationTemplate template, Map<String, Object> variables) {
        switch (channel) {
            case EMAIL -> emailService.send(
                user.getEmail(),
                template.getSubject(),
                template.renderBody(variables)
            );
            case SMS -> smsService.send(
                user.getPhoneNumber(),
                template.renderSmsBody(variables)
            );
            case PUSH -> pushService.send(
                user.getDeviceTokens(),
                template.getTitle(),
                template.renderPushBody(variables)
            );
        }
    }

    private void sendToAllChannels(User user, NotificationTemplate template, 
                                    Map<String, Object> variables, NotificationType type) {
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        List<NotificationChannel> channels = determineChannels(prefs, type);
        
        for (NotificationChannel channel : channels) {
            try {
                sendViaChannel(channel, user, template, variables);
                logNotification(user.getId(), type, channel, "SUCCESS");
            } catch (Exception e) {
                log.error("Notification failed: {} via {} - {}", type, channel, e.getMessage());
                logNotification(user.getId(), type, channel, "FAILED");
            }
        }
    }

    private List<NotificationChannel> determineChannels(NotificationPreferences prefs, 
                                                         NotificationType type) {
        return prefs.getChannelPreferences().entrySet().stream()
            .filter(e -> e.getValue().contains(type))
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }

    private void logNotification(Long userId, NotificationType type, 
                                  NotificationChannel channel, String status) {
        NotificationLog log = NotificationLog.builder()
            .userId(userId)
            .type(type)
            .channel(channel)
            .status(status)
            .sentAt(Instant.now())
            .build();
        
        notificationRepository.save(log);
    }

    private Map<String, Object> buildOrderVariables(Order order) {
        return Map.of(
            "orderId", order.getId(),
            "items", order.getItems(),
            "subtotal", order.getSubtotal(),
            "tax", order.getTax(),
            "shipping", order.getShippingCost(),
            "total", order.getTotal(),
            "shippingAddress", order.getShippingAddress(),
            "estimatedDelivery", calculateEstimatedDelivery(order)
        );
    }
}
```

================================================================================
## MODULE 6: Reporting and Analytics
================================================================================

```java
package com.example.analytics.service;

import org.springframework.stereotype.Service;
import org.springframework.cache.annotation.Cacheable;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class AnalyticsService {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;
    private final InventoryRepository inventoryRepository;
    private final RevenueCalculator revenueCalculator;

    @Cacheable(value = "salesReport", key = "#startDate + '-' + #endDate")
    public SalesReport generateSalesReport(LocalDate startDate, LocalDate endDate) {
        log.info("Generating sales report for {} to {}", startDate, endDate);
        
        List<Order> orders = orderRepository.findByCreatedAtBetween(
            startDate.atStartOfDay().toInstant(ZoneOffset.UTC),
            endDate.plusDays(1).atStartOfDay().toInstant(ZoneOffset.UTC)
        );
        
        // Filter completed orders only
        List<Order> completedOrders = orders.stream()
            .filter(o -> o.getStatus() == OrderStatus.COMPLETED || 
                        o.getStatus() == OrderStatus.DELIVERED)
            .collect(Collectors.toList());
        
        // Calculate metrics
        BigDecimal totalRevenue = completedOrders.stream()
            .map(Order::getTotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal totalTax = completedOrders.stream()
            .map(Order::getTax)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal averageOrderValue = completedOrders.isEmpty() 
            ? BigDecimal.ZERO 
            : totalRevenue.divide(BigDecimal.valueOf(completedOrders.size()), RoundingMode.HALF_UP);
        
        // Daily breakdown
        Map<LocalDate, DailySales> dailyBreakdown = completedOrders.stream()
            .collect(Collectors.groupingBy(
                o -> o.getCreatedAt().atZone(ZoneOffset.UTC).toLocalDate(),
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    this::calculateDailySales
                )
            ));
        
        // Top products
        List<ProductSales> topProducts = calculateTopProducts(completedOrders, 10);
        
        // Category breakdown
        Map<String, CategorySales> categoryBreakdown = calculateCategoryBreakdown(completedOrders);
        
        return SalesReport.builder()
            .startDate(startDate)
            .endDate(endDate)
            .totalOrders(completedOrders.size())
            .totalRevenue(totalRevenue)
            .totalTax(totalTax)
            .averageOrderValue(averageOrderValue)
            .dailyBreakdown(dailyBreakdown)
            .topProducts(topProducts)
            .categoryBreakdown(categoryBreakdown)
            .generatedAt(Instant.now())
            .build();
    }

    @Cacheable(value = "customerAnalytics", key = "#customerId")
    public CustomerAnalytics getCustomerAnalytics(Long customerId) {
        User customer = userRepository.findById(customerId)
            .orElseThrow(() -> new UserNotFoundException(customerId));
        
        List<Order> orders = orderRepository.findByCustomerId(customerId);
        
        BigDecimal totalSpent = orders.stream()
            .filter(o -> o.getStatus() == OrderStatus.COMPLETED)
            .map(Order::getTotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal averageOrderValue = orders.isEmpty() 
            ? BigDecimal.ZERO 
            : totalSpent.divide(BigDecimal.valueOf(orders.size()), RoundingMode.HALF_UP);
        
        // Purchase frequency
        long daysSinceFirstOrder = orders.isEmpty() ? 0 :
            ChronoUnit.DAYS.between(
                orders.stream().map(Order::getCreatedAt).min(Instant::compareTo).get()
                    .atZone(ZoneOffset.UTC).toLocalDate(),
                LocalDate.now()
            );
        
        double ordersPerMonth = daysSinceFirstOrder > 0 
            ? (double) orders.size() / (daysSinceFirstOrder / 30.0) 
            : 0;
        
        // Favorite categories
        Map<String, Long> categoryPreferences = orders.stream()
            .flatMap(o -> o.getItems().stream())
            .collect(Collectors.groupingBy(
                item -> productRepository.findById(item.getProductId())
                    .map(Product::getCategory)
                    .orElse("Unknown"),
                Collectors.counting()
            ));
        
        // Customer segment
        CustomerSegment segment = determineCustomerSegment(totalSpent, orders.size(), ordersPerMonth);
        
        return CustomerAnalytics.builder()
            .customerId(customerId)
            .customerName(customer.getName())
            .memberSince(customer.getCreatedAt())
            .totalOrders(orders.size())
            .totalSpent(totalSpent)
            .averageOrderValue(averageOrderValue)
            .ordersPerMonth(ordersPerMonth)
            .categoryPreferences(categoryPreferences)
            .segment(segment)
            .lastOrderDate(orders.stream()
                .map(Order::getCreatedAt)
                .max(Instant::compareTo)
                .orElse(null))
            .build();
    }

    public InventoryReport generateInventoryReport() {
        List<InventoryItem> allItems = inventoryRepository.findAll();
        
        // Group by product
        Map<Long, List<InventoryItem>> byProduct = allItems.stream()
            .collect(Collectors.groupingBy(InventoryItem::getProductId));
        
        List<ProductInventoryStatus> productStatuses = byProduct.entrySet().stream()
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                List<InventoryItem> items = entry.getValue();
                
                int totalOnHand = items.stream().mapToInt(InventoryItem::getQuantityOnHand).sum();
                int totalReserved = items.stream().mapToInt(InventoryItem::getQuantityReserved).sum();
                
                InventoryHealthStatus health = determineHealthStatus(items);
                
                return ProductInventoryStatus.builder()
                    .productId(entry.getKey())
                    .productName(product != null ? product.getName() : "Unknown")
                    .totalOnHand(totalOnHand)
                    .totalReserved(totalReserved)
                    .totalAvailable(totalOnHand - totalReserved)
                    .health(health)
                    .warehouseBreakdown(items.stream()
                        .collect(Collectors.toMap(
                            InventoryItem::getWarehouseId,
                            i -> i.getQuantityOnHand() - i.getQuantityReserved()
                        )))
                    .build();
            })
            .sorted(Comparator.comparing(ProductInventoryStatus::getHealth))
            .collect(Collectors.toList());
        
        // Summary metrics
        long criticalItems = productStatuses.stream()
            .filter(p -> p.getHealth() == InventoryHealthStatus.CRITICAL)
            .count();
        
        long lowStockItems = productStatuses.stream()
            .filter(p -> p.getHealth() == InventoryHealthStatus.LOW)
            .count();
        
        BigDecimal totalInventoryValue = productStatuses.stream()
            .map(p -> {
                Product product = productRepository.findById(p.getProductId()).orElse(null);
                return product != null 
                    ? product.getCost().multiply(BigDecimal.valueOf(p.getTotalOnHand()))
                    : BigDecimal.ZERO;
            })
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        return InventoryReport.builder()
            .generatedAt(Instant.now())
            .totalProducts(productStatuses.size())
            .criticalStockItems(criticalItems)
            .lowStockItems(lowStockItems)
            .healthyStockItems(productStatuses.size() - criticalItems - lowStockItems)
            .totalInventoryValue(totalInventoryValue)
            .productStatuses(productStatuses)
            .build();
    }

    @Scheduled(cron = "0 0 1 * * *")
    public void generateDailyMetrics() {
        LocalDate yesterday = LocalDate.now().minusDays(1);
        
        DailyMetrics metrics = DailyMetrics.builder()
            .date(yesterday)
            .salesReport(generateSalesReport(yesterday, yesterday))
            .newCustomers(userRepository.countByCreatedAtBetween(
                yesterday.atStartOfDay().toInstant(ZoneOffset.UTC),
                yesterday.plusDays(1).atStartOfDay().toInstant(ZoneOffset.UTC)
            ))
            .activeUsers(sessionRepository.countDistinctUsersByDate(yesterday))
            .conversionRate(calculateConversionRate(yesterday))
            .build();
        
        metricsRepository.save(metrics);
        
        log.info("Daily metrics generated for {}: {} orders, {} revenue", 
            yesterday, metrics.getSalesReport().getTotalOrders(), 
            metrics.getSalesReport().getTotalRevenue());
    }

    private DailySales calculateDailySales(List<Order> orders) {
        return DailySales.builder()
            .orderCount(orders.size())
            .revenue(orders.stream()
                .map(Order::getTotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add))
            .build();
    }

    private List<ProductSales> calculateTopProducts(List<Order> orders, int limit) {
        Map<Long, ProductSalesAccumulator> accumulator = new HashMap<>();
        
        for (Order order : orders) {
            for (OrderItem item : order.getItems()) {
                accumulator.computeIfAbsent(item.getProductId(), 
                    k -> new ProductSalesAccumulator(item.getProductId(), item.getProductName()))
                    .add(item.getQuantity(), item.getTotalPrice());
            }
        }
        
        return accumulator.values().stream()
            .sorted(Comparator.comparing(ProductSalesAccumulator::getRevenue).reversed())
            .limit(limit)
            .map(ProductSalesAccumulator::toProductSales)
            .collect(Collectors.toList());
    }

    private Map<String, CategorySales> calculateCategoryBreakdown(List<Order> orders) {
        Map<String, CategorySalesAccumulator> accumulator = new HashMap<>();
        
        for (Order order : orders) {
            for (OrderItem item : order.getItems()) {
                String category = productRepository.findById(item.getProductId())
                    .map(Product::getCategory)
                    .orElse("Uncategorized");
                
                accumulator.computeIfAbsent(category, CategorySalesAccumulator::new)
                    .add(item.getQuantity(), item.getTotalPrice());
            }
        }
        
        return accumulator.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().toCategorySales()
            ));
    }

    private CustomerSegment determineCustomerSegment(BigDecimal totalSpent, int orderCount, 
                                                      double ordersPerMonth) {
        if (totalSpent.compareTo(BigDecimal.valueOf(10000)) > 0 && ordersPerMonth > 2) {
            return CustomerSegment.VIP;
        } else if (totalSpent.compareTo(BigDecimal.valueOf(5000)) > 0 && ordersPerMonth > 1) {
            return CustomerSegment.LOYAL;
        } else if (orderCount > 5) {
            return CustomerSegment.REGULAR;
        } else if (orderCount > 0) {
            return CustomerSegment.OCCASIONAL;
        } else {
            return CustomerSegment.NEW;
        }
    }

    private InventoryHealthStatus determineHealthStatus(List<InventoryItem> items) {
        int totalAvailable = items.stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        int avgReorderPoint = (int) items.stream()
            .mapToInt(InventoryItem::getReorderPoint)
            .average()
            .orElse(0);
        
        if (totalAvailable <= 0) {
            return InventoryHealthStatus.OUT_OF_STOCK;
        } else if (totalAvailable <= avgReorderPoint / 2) {
            return InventoryHealthStatus.CRITICAL;
        } else if (totalAvailable <= avgReorderPoint) {
            return InventoryHealthStatus.LOW;
        } else {
            return InventoryHealthStatus.HEALTHY;
        }
    }
}
```

================================================================================
## MODULE 7: Search and Recommendation Engine
================================================================================

```java
package com.example.search.service;

import org.springframework.stereotype.Service;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class SearchAndRecommendationService {

    private final RestHighLevelClient elasticsearchClient;
    private final ProductRepository productRepository;
    private final UserBehaviorRepository behaviorRepository;
    private final SimilarityCalculator similarityCalculator;
    private final MLRecommendationClient mlClient;

    public SearchResults search(SearchRequest request) {
        log.info("Searching for: {} with filters: {}", request.getQuery(), request.getFilters());
        
        SearchSourceBuilder searchBuilder = new SearchSourceBuilder();
        
        // Build query
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // Full-text search on name, description, tags
        if (StringUtils.isNotBlank(request.getQuery())) {
            boolQuery.must(QueryBuilders.multiMatchQuery(request.getQuery())
                .field("name", 3.0f)
                .field("description", 1.0f)
                .field("tags", 2.0f)
                .field("category", 1.5f)
                .fuzziness(Fuzziness.AUTO)
                .prefixLength(2));
        }
        
        // Apply filters
        if (request.getFilters() != null) {
            applyFilters(boolQuery, request.getFilters());
        }
        
        searchBuilder.query(boolQuery);
        
        // Sorting
        if (request.getSortBy() != null) {
            searchBuilder.sort(request.getSortBy(), 
                request.getSortOrder() == SortOrder.DESC ? SortOrder.DESC : SortOrder.ASC);
        } else {
            searchBuilder.sort("_score", SortOrder.DESC);
        }
        
        // Pagination
        searchBuilder.from(request.getPage() * request.getSize());
        searchBuilder.size(request.getSize());
        
        // Execute search
        SearchResponse response = elasticsearchClient.search(
            new SearchRequest("products").source(searchBuilder),
            RequestOptions.DEFAULT
        );
        
        // Map results
        List<ProductSearchResult> results = Arrays.stream(response.getHits().getHits())
            .map(hit -> {
                Map<String, Object> source = hit.getSourceAsMap();
                return ProductSearchResult.builder()
                    .productId(Long.parseLong(hit.getId()))
                    .name((String) source.get("name"))
                    .description((String) source.get("description"))
                    .price(new BigDecimal(source.get("price").toString()))
                    .category((String) source.get("category"))
                    .imageUrl((String) source.get("imageUrl"))
                    .rating((Double) source.get("rating"))
                    .score(hit.getScore())
                    .build();
            })
            .collect(Collectors.toList());
        
        // Get facets/aggregations
        Map<String, List<FacetValue>> facets = extractFacets(response.getAggregations());
        
        // Log search for analytics
        logSearchEvent(request, response.getHits().getTotalHits().value);
        
        return SearchResults.builder()
            .query(request.getQuery())
            .results(results)
            .totalHits(response.getHits().getTotalHits().value)
            .page(request.getPage())
            .size(request.getSize())
            .facets(facets)
            .searchTime(response.getTook().getMillis())
            .build();
    }

    public List<ProductRecommendation> getPersonalizedRecommendations(Long userId, int limit) {
        log.debug("Getting personalized recommendations for user: {}", userId);
        
        // Get user behavior history
        UserBehaviorProfile profile = buildUserProfile(userId);
        
        // Try ML-based recommendations first
        try {
            List<Long> mlRecommendations = mlClient.getRecommendations(userId, limit * 2);
            
            if (!mlRecommendations.isEmpty()) {
                return mlRecommendations.stream()
                    .map(productId -> productRepository.findById(productId).orElse(null))
                    .filter(Objects::nonNull)
                    .filter(p -> !profile.getPurchasedProductIds().contains(p.getId()))
                    .limit(limit)
                    .map(p -> ProductRecommendation.builder()
                        .product(p)
                        .reason("Based on your shopping history")
                        .score(0.9)
                        .build())
                    .collect(Collectors.toList());
            }
        } catch (Exception e) {
            log.warn("ML recommendation service unavailable, falling back to rule-based", e);
        }
        
        // Fallback: Rule-based recommendations
        return getRuleBasedRecommendations(profile, limit);
    }

    public List<ProductRecommendation> getSimilarProducts(Long productId, int limit) {
        Product baseProduct = productRepository.findById(productId)
            .orElseThrow(() -> new ProductNotFoundException(productId));
        
        // Get products in same category
        List<Product> categoryProducts = productRepository.findByCategory(baseProduct.getCategory());
        
        // Calculate similarity scores
        return categoryProducts.stream()
            .filter(p -> !p.getId().equals(productId))
            .map(p -> {
                double similarity = similarityCalculator.calculate(baseProduct, p);
                return ProductRecommendation.builder()
                    .product(p)
                    .reason("Similar to " + baseProduct.getName())
                    .score(similarity)
                    .build();
            })
            .filter(r -> r.getScore() > 0.3)
            .sorted(Comparator.comparing(ProductRecommendation::getScore).reversed())
            .limit(limit)
            .collect(Collectors.toList());
    }

    public List<ProductRecommendation> getFrequentlyBoughtTogether(Long productId, int limit) {
        // Find orders containing this product
        List<Order> ordersWithProduct = orderRepository.findByItemsProductId(productId);
        
        // Count co-occurrence of other products
        Map<Long, Long> coOccurrence = ordersWithProduct.stream()
            .flatMap(o -> o.getItems().stream())
            .map(OrderItem::getProductId)
            .filter(id -> !id.equals(productId))
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        
        // Get top co-occurring products
        return coOccurrence.entrySet().stream()
            .sorted(Map.Entry.<Long, Long>comparingByValue().reversed())
            .limit(limit)
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                if (product == null) return null;
                
                double score = (double) entry.getValue() / ordersWithProduct.size();
                return ProductRecommendation.builder()
                    .product(product)
                    .reason("Frequently bought together")
                    .score(score)
                    .build();
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }

    public List<ProductRecommendation> getTrendingProducts(int limit) {
        LocalDate weekAgo = LocalDate.now().minusDays(7);
        
        // Get recent orders
        List<Order> recentOrders = orderRepository.findByCreatedAtAfter(
            weekAgo.atStartOfDay().toInstant(ZoneOffset.UTC)
        );
        
        // Count product sales with recency weighting
        Map<Long, Double> trendingScores = new HashMap<>();
        
        for (Order order : recentOrders) {
            long daysAgo = ChronoUnit.DAYS.between(
                order.getCreatedAt().atZone(ZoneOffset.UTC).toLocalDate(),
                LocalDate.now()
            );
            double recencyWeight = 1.0 / (1.0 + daysAgo * 0.1);
            
            for (OrderItem item : order.getItems()) {
                trendingScores.merge(item.getProductId(), 
                    item.getQuantity() * recencyWeight, 
                    Double::sum);
            }
        }
        
        // Normalize and return top trending
        double maxScore = trendingScores.values().stream()
            .max(Double::compareTo)
            .orElse(1.0);
        
        return trendingScores.entrySet().stream()
            .sorted(Map.Entry.<Long, Double>comparingByValue().reversed())
            .limit(limit)
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                if (product == null) return null;
                
                return ProductRecommendation.builder()
                    .product(product)
                    .reason("Trending this week")
                    .score(entry.getValue() / maxScore)
                    .build();
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }

    @Async
    public void trackUserBehavior(Long userId, BehaviorEvent event) {
        UserBehavior behavior = UserBehavior.builder()
            .userId(userId)
            .eventType(event.getType())
            .productId(event.getProductId())
            .searchQuery(event.getSearchQuery())
            .timestamp(Instant.now())
            .sessionId(event.getSessionId())
            .metadata(event.getMetadata())
            .build();
        
        behaviorRepository.save(behavior);
        
        // Update real-time recommendations cache if significant event
        if (event.getType() == BehaviorType.PURCHASE || 
            event.getType() == BehaviorType.ADD_TO_CART) {
            recommendationCache.invalidate(userId);
        }
    }

    private void applyFilters(BoolQueryBuilder boolQuery, SearchFilters filters) {
        if (filters.getCategories() != null && !filters.getCategories().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("category", filters.getCategories()));
        }
        
        if (filters.getMinPrice() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("price").gte(filters.getMinPrice()));
        }
        
        if (filters.getMaxPrice() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("price").lte(filters.getMaxPrice()));
        }
        
        if (filters.getMinRating() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("rating").gte(filters.getMinRating()));
        }
        
        if (filters.getInStock() != null && filters.getInStock()) {
            boolQuery.filter(QueryBuilders.termQuery("inStock", true));
        }
        
        if (filters.getBrands() != null && !filters.getBrands().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("brand", filters.getBrands()));
        }
        
        if (filters.getTags() != null && !filters.getTags().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("tags", filters.getTags()));
        }
    }

    private UserBehaviorProfile buildUserProfile(Long userId) {
        List<UserBehavior> behaviors = behaviorRepository.findByUserIdOrderByTimestampDesc(
            userId, PageRequest.of(0, 1000)
        );
        
        Set<Long> purchasedProducts = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.PURCHASE)
            .map(UserBehavior::getProductId)
            .collect(Collectors.toSet());
        
        Set<Long> viewedProducts = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.VIEW)
            .map(UserBehavior::getProductId)
            .collect(Collectors.toSet());
        
        Map<String, Long> categoryInterests = behaviors.stream()
            .filter(b -> b.getProductId() != null)
            .map(b -> productRepository.findById(b.getProductId())
                .map(Product::getCategory)
                .orElse(null))
            .filter(Objects::nonNull)
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        
        List<String> recentSearches = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.SEARCH)
            .map(UserBehavior::getSearchQuery)
            .filter(Objects::nonNull)
            .limit(20)
            .collect(Collectors.toList());
        
        return UserBehaviorProfile.builder()
            .userId(userId)
            .purchasedProductIds(purchasedProducts)
            .viewedProductIds(viewedProducts)
            .categoryInterests(categoryInterests)
            .recentSearches(recentSearches)
            .build();
    }

    private List<ProductRecommendation> getRuleBasedRecommendations(UserBehaviorProfile profile, 
                                                                      int limit) {
        List<ProductRecommendation> recommendations = new ArrayList<>();
        
        // 1. Products from favorite categories
        String topCategory = profile.getCategoryInterests().entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
        
        if (topCategory != null) {
            productRepository.findByCategoryAndIdNotIn(topCategory, profile.getPurchasedProductIds())
                .stream()
                .limit(limit / 2)
                .forEach(p -> recommendations.add(ProductRecommendation.builder()
                    .product(p)
                    .reason("Based on your interest in " + topCategory)
                    .score(0.7)
                    .build()));
        }
        
        // 2. Highly rated products user hasn't purchased
        productRepository.findTopRatedNotPurchased(profile.getPurchasedProductIds(), limit / 2)
            .forEach(p -> recommendations.add(ProductRecommendation.builder()
                .product(p)
                .reason("Top rated product")
                .score(0.6)
                .build()));
        
        return recommendations.stream()
            .distinct()
            .limit(limit)
            .collect(Collectors.toList());
    }
}
```

================================================================================
## END OF FILE - REPEAT SECTION FOR SIZE
================================================================================
# Large Codebase Simulation File
# This file simulates a large codebase for context overflow testing
# Generated for focus-task plugin testing

================================================================================
## MODULE 1: Authentication Service
================================================================================

```java
package com.example.auth.service;

import org.springframework.stereotype.Service;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class AuthenticationService {

    private final UserRepository userRepository;
    private final TokenService tokenService;
    private final BCryptPasswordEncoder passwordEncoder;
    private final AuditLogService auditLogService;

    public AuthResponse authenticate(AuthRequest request) {
        log.info("Authentication attempt for user: {}", request.getUsername());
        
        User user = userRepository.findByUsername(request.getUsername())
            .orElseThrow(() -> new AuthenticationException("User not found"));
        
        if (!passwordEncoder.matches(request.getPassword(), user.getPasswordHash())) {
            auditLogService.logFailedLogin(user.getId(), request.getIpAddress());
            throw new AuthenticationException("Invalid credentials");
        }
        
        if (!user.isEnabled()) {
            throw new AuthenticationException("Account disabled");
        }
        
        String accessToken = tokenService.generateAccessToken(user);
        String refreshToken = tokenService.generateRefreshToken(user);
        
        auditLogService.logSuccessfulLogin(user.getId(), request.getIpAddress());
        
        return AuthResponse.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .expiresIn(tokenService.getAccessTokenExpiration())
            .tokenType("Bearer")
            .build();
    }

    public AuthResponse refreshToken(String refreshToken) {
        TokenClaims claims = tokenService.validateRefreshToken(refreshToken);
        
        User user = userRepository.findById(claims.getUserId())
            .orElseThrow(() -> new AuthenticationException("User not found"));
        
        String newAccessToken = tokenService.generateAccessToken(user);
        
        return AuthResponse.builder()
            .accessToken(newAccessToken)
            .refreshToken(refreshToken)
            .expiresIn(tokenService.getAccessTokenExpiration())
            .tokenType("Bearer")
            .build();
    }

    public void logout(String accessToken) {
        tokenService.revokeToken(accessToken);
        log.info("User logged out successfully");
    }

    public void changePassword(Long userId, ChangePasswordRequest request) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException(userId));
        
        if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPasswordHash())) {
            throw new AuthenticationException("Current password is incorrect");
        }
        
        validatePasswordStrength(request.getNewPassword());
        
        user.setPasswordHash(passwordEncoder.encode(request.getNewPassword()));
        user.setPasswordChangedAt(Instant.now());
        userRepository.save(user);
        
        tokenService.revokeAllUserTokens(userId);
        auditLogService.logPasswordChange(userId);
    }

    private void validatePasswordStrength(String password) {
        if (password.length() < 12) {
            throw new ValidationException("Password must be at least 12 characters");
        }
        if (!password.matches(".*[A-Z].*")) {
            throw new ValidationException("Password must contain uppercase letter");
        }
        if (!password.matches(".*[a-z].*")) {
            throw new ValidationException("Password must contain lowercase letter");
        }
        if (!password.matches(".*\\d.*")) {
            throw new ValidationException("Password must contain digit");
        }
        if (!password.matches(".*[!@#$%^&*()].*")) {
            throw new ValidationException("Password must contain special character");
        }
    }
}
```

================================================================================
## MODULE 2: Order Processing Service
================================================================================

```java
package com.example.orders.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class OrderProcessingService {

    private final OrderRepository orderRepository;
    private final ProductService productService;
    private final InventoryService inventoryService;
    private final PaymentService paymentService;
    private final NotificationService notificationService;
    private final ShippingService shippingService;
    private final TaxCalculationService taxService;
    private final DiscountService discountService;

    @Transactional
    public OrderResponse createOrder(CreateOrderRequest request) {
        log.info("Creating order for customer: {}", request.getCustomerId());
        
        // Validate products availability
        List<OrderItem> items = request.getItems().stream()
            .map(this::validateAndCreateOrderItem)
            .collect(Collectors.toList());
        
        // Calculate totals
        BigDecimal subtotal = calculateSubtotal(items);
        BigDecimal discount = discountService.calculateDiscount(request.getPromoCode(), subtotal);
        BigDecimal tax = taxService.calculateTax(subtotal.subtract(discount), request.getShippingAddress());
        BigDecimal shippingCost = shippingService.calculateShippingCost(items, request.getShippingAddress());
        BigDecimal total = subtotal.subtract(discount).add(tax).add(shippingCost);
        
        // Create order
        Order order = Order.builder()
            .customerId(request.getCustomerId())
            .items(items)
            .subtotal(subtotal)
            .discount(discount)
            .tax(tax)
            .shippingCost(shippingCost)
            .total(total)
            .status(OrderStatus.PENDING)
            .shippingAddress(request.getShippingAddress())
            .billingAddress(request.getBillingAddress())
            .createdAt(Instant.now())
            .build();
        
        order = orderRepository.save(order);
        
        // Reserve inventory
        items.forEach(item -> inventoryService.reserveStock(item.getProductId(), item.getQuantity()));
        
        log.info("Order {} created successfully with total: {}", order.getId(), total);
        
        return mapToResponse(order);
    }

    @Transactional
    public OrderResponse processPayment(Long orderId, PaymentRequest paymentRequest) {
        Order order = getOrderOrThrow(orderId);
        
        if (order.getStatus() != OrderStatus.PENDING) {
            throw new OrderProcessingException("Order is not in pending status");
        }
        
        PaymentResult result = paymentService.processPayment(
            paymentRequest.getPaymentMethodId(),
            order.getTotal(),
            order.getId().toString()
        );
        
        if (result.isSuccessful()) {
            order.setStatus(OrderStatus.PAID);
            order.setPaymentId(result.getTransactionId());
            order.setPaidAt(Instant.now());
            
            // Commit inventory reservation
            order.getItems().forEach(item -> 
                inventoryService.commitReservation(item.getProductId(), item.getQuantity()));
            
            // Trigger fulfillment
            shippingService.createShipment(order);
            
            // Send confirmation
            notificationService.sendOrderConfirmation(order);
            
            log.info("Payment processed successfully for order: {}", orderId);
        } else {
            order.setStatus(OrderStatus.PAYMENT_FAILED);
            order.setPaymentError(result.getErrorMessage());
            
            // Release inventory reservation
            order.getItems().forEach(item -> 
                inventoryService.releaseReservation(item.getProductId(), item.getQuantity()));
            
            log.warn("Payment failed for order: {} - {}", orderId, result.getErrorMessage());
        }
        
        orderRepository.save(order);
        return mapToResponse(order);
    }

    @Transactional
    public OrderResponse cancelOrder(Long orderId, String reason) {
        Order order = getOrderOrThrow(orderId);
        
        if (!order.getStatus().isCancellable()) {
            throw new OrderProcessingException("Order cannot be cancelled in current status");
        }
        
        // Refund if already paid
        if (order.getPaymentId() != null) {
            paymentService.refund(order.getPaymentId(), order.getTotal());
        }
        
        // Release inventory
        order.getItems().forEach(item -> 
            inventoryService.releaseStock(item.getProductId(), item.getQuantity()));
        
        order.setStatus(OrderStatus.CANCELLED);
        order.setCancellationReason(reason);
        order.setCancelledAt(Instant.now());
        
        orderRepository.save(order);
        
        notificationService.sendOrderCancellation(order);
        
        log.info("Order {} cancelled: {}", orderId, reason);
        
        return mapToResponse(order);
    }

    public List<OrderResponse> getCustomerOrders(Long customerId, Pageable pageable) {
        return orderRepository.findByCustomerId(customerId, pageable)
            .stream()
            .map(this::mapToResponse)
            .collect(Collectors.toList());
    }

    public OrderResponse getOrderDetails(Long orderId) {
        return mapToResponse(getOrderOrThrow(orderId));
    }

    private OrderItem validateAndCreateOrderItem(OrderItemRequest request) {
        Product product = productService.getProduct(request.getProductId());
        
        if (!product.isAvailable()) {
            throw new ProductNotAvailableException(product.getId());
        }
        
        if (!inventoryService.hasStock(product.getId(), request.getQuantity())) {
            throw new InsufficientStockException(product.getId(), request.getQuantity());
        }
        
        return OrderItem.builder()
            .productId(product.getId())
            .productName(product.getName())
            .quantity(request.getQuantity())
            .unitPrice(product.getPrice())
            .totalPrice(product.getPrice().multiply(BigDecimal.valueOf(request.getQuantity())))
            .build();
    }

    private BigDecimal calculateSubtotal(List<OrderItem> items) {
        return items.stream()
            .map(OrderItem::getTotalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    private Order getOrderOrThrow(Long orderId) {
        return orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
    }

    private OrderResponse mapToResponse(Order order) {
        return OrderResponse.builder()
            .id(order.getId())
            .customerId(order.getCustomerId())
            .items(order.getItems().stream()
                .map(this::mapItemToResponse)
                .collect(Collectors.toList()))
            .subtotal(order.getSubtotal())
            .discount(order.getDiscount())
            .tax(order.getTax())
            .shippingCost(order.getShippingCost())
            .total(order.getTotal())
            .status(order.getStatus())
            .createdAt(order.getCreatedAt())
            .build();
    }

    private OrderItemResponse mapItemToResponse(OrderItem item) {
        return OrderItemResponse.builder()
            .productId(item.getProductId())
            .productName(item.getProductName())
            .quantity(item.getQuantity())
            .unitPrice(item.getUnitPrice())
            .totalPrice(item.getTotalPrice())
            .build();
    }
}
```

================================================================================
## MODULE 3: Inventory Management System
================================================================================

```java
package com.example.inventory.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
@Slf4j
@RequiredArgsConstructor
public class InventoryManagementService {

    private final InventoryRepository inventoryRepository;
    private final WarehouseRepository warehouseRepository;
    private final ReorderService reorderService;
    private final NotificationService notificationService;
    private final AuditService auditService;
    
    private final Map<String, ReservationLock> reservationLocks = new ConcurrentHashMap<>();

    @Transactional
    public InventoryItem addStock(Long productId, Long warehouseId, int quantity, String reason) {
        log.info("Adding {} units of product {} to warehouse {}", quantity, productId, warehouseId);
        
        InventoryItem item = getOrCreateInventoryItem(productId, warehouseId);
        int previousQuantity = item.getQuantityOnHand();
        
        item.setQuantityOnHand(item.getQuantityOnHand() + quantity);
        item.setLastRestockedAt(Instant.now());
        
        inventoryRepository.save(item);
        
        auditService.logInventoryChange(
            productId, warehouseId, previousQuantity, item.getQuantityOnHand(), reason
        );
        
        checkReorderThreshold(item);
        
        return item;
    }

    @Transactional
    public synchronized boolean reserveStock(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdOrderByQuantityDesc(productId);
        
        int totalAvailable = items.stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        if (totalAvailable < quantity) {
            log.warn("Insufficient stock for product {}: requested {}, available {}", 
                productId, quantity, totalAvailable);
            return false;
        }
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int available = item.getQuantityOnHand() - item.getQuantityReserved();
            int toReserve = Math.min(available, remaining);
            
            if (toReserve > 0) {
                item.setQuantityReserved(item.getQuantityReserved() + toReserve);
                inventoryRepository.save(item);
                remaining -= toReserve;
                
                log.debug("Reserved {} units from warehouse {} for product {}", 
                    toReserve, item.getWarehouseId(), productId);
            }
        }
        
        return true;
    }

    @Transactional
    public void commitReservation(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdAndQuantityReservedGreaterThan(productId, 0);
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int toCommit = Math.min(item.getQuantityReserved(), remaining);
            
            item.setQuantityOnHand(item.getQuantityOnHand() - toCommit);
            item.setQuantityReserved(item.getQuantityReserved() - toCommit);
            inventoryRepository.save(item);
            
            remaining -= toCommit;
            
            checkReorderThreshold(item);
        }
        
        log.info("Committed reservation of {} units for product {}", quantity, productId);
    }

    @Transactional
    public void releaseReservation(Long productId, int quantity) {
        List<InventoryItem> items = inventoryRepository.findByProductIdAndQuantityReservedGreaterThan(productId, 0);
        
        int remaining = quantity;
        for (InventoryItem item : items) {
            if (remaining <= 0) break;
            
            int toRelease = Math.min(item.getQuantityReserved(), remaining);
            item.setQuantityReserved(item.getQuantityReserved() - toRelease);
            inventoryRepository.save(item);
            
            remaining -= toRelease;
        }
        
        log.info("Released reservation of {} units for product {}", quantity, productId);
    }

    public boolean hasStock(Long productId, int quantity) {
        int available = inventoryRepository.findByProductId(productId).stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        return available >= quantity;
    }

    public InventoryStatus getInventoryStatus(Long productId) {
        List<InventoryItem> items = inventoryRepository.findByProductId(productId);
        
        int totalOnHand = items.stream().mapToInt(InventoryItem::getQuantityOnHand).sum();
        int totalReserved = items.stream().mapToInt(InventoryItem::getQuantityReserved).sum();
        int totalAvailable = totalOnHand - totalReserved;
        
        return InventoryStatus.builder()
            .productId(productId)
            .totalOnHand(totalOnHand)
            .totalReserved(totalReserved)
            .totalAvailable(totalAvailable)
            .warehouseBreakdown(items.stream()
                .collect(Collectors.toMap(
                    InventoryItem::getWarehouseId,
                    i -> new WarehouseStock(i.getQuantityOnHand(), i.getQuantityReserved())
                )))
            .build();
    }

    @Scheduled(cron = "0 0 * * * *")
    public void checkLowStockLevels() {
        log.info("Running scheduled low stock check");
        
        List<InventoryItem> lowStockItems = inventoryRepository.findItemsBelowReorderPoint();
        
        for (InventoryItem item : lowStockItems) {
            if (!reorderService.hasPendingReorder(item.getProductId())) {
                ReorderRequest request = calculateReorderQuantity(item);
                reorderService.createReorderRequest(request);
                
                notificationService.sendLowStockAlert(item);
                
                log.info("Created reorder request for product {} at warehouse {}", 
                    item.getProductId(), item.getWarehouseId());
            }
        }
    }

    @Transactional
    public void transferStock(Long productId, Long fromWarehouse, Long toWarehouse, int quantity) {
        InventoryItem source = inventoryRepository.findByProductIdAndWarehouseId(productId, fromWarehouse)
            .orElseThrow(() -> new InventoryNotFoundException(productId, fromWarehouse));
        
        int available = source.getQuantityOnHand() - source.getQuantityReserved();
        if (available < quantity) {
            throw new InsufficientStockException(productId, quantity);
        }
        
        source.setQuantityOnHand(source.getQuantityOnHand() - quantity);
        inventoryRepository.save(source);
        
        InventoryItem destination = getOrCreateInventoryItem(productId, toWarehouse);
        destination.setQuantityOnHand(destination.getQuantityOnHand() + quantity);
        inventoryRepository.save(destination);
        
        auditService.logStockTransfer(productId, fromWarehouse, toWarehouse, quantity);
        
        log.info("Transferred {} units of product {} from warehouse {} to {}", 
            quantity, productId, fromWarehouse, toWarehouse);
    }

    private InventoryItem getOrCreateInventoryItem(Long productId, Long warehouseId) {
        return inventoryRepository.findByProductIdAndWarehouseId(productId, warehouseId)
            .orElseGet(() -> {
                Warehouse warehouse = warehouseRepository.findById(warehouseId)
                    .orElseThrow(() -> new WarehouseNotFoundException(warehouseId));
                
                return InventoryItem.builder()
                    .productId(productId)
                    .warehouseId(warehouseId)
                    .quantityOnHand(0)
                    .quantityReserved(0)
                    .reorderPoint(warehouse.getDefaultReorderPoint())
                    .reorderQuantity(warehouse.getDefaultReorderQuantity())
                    .build();
            });
    }

    private void checkReorderThreshold(InventoryItem item) {
        int available = item.getQuantityOnHand() - item.getQuantityReserved();
        
        if (available <= item.getReorderPoint()) {
            log.info("Product {} at warehouse {} below reorder point: {} <= {}", 
                item.getProductId(), item.getWarehouseId(), available, item.getReorderPoint());
            
            if (!reorderService.hasPendingReorder(item.getProductId())) {
                ReorderRequest request = calculateReorderQuantity(item);
                reorderService.createReorderRequest(request);
            }
        }
    }

    private ReorderRequest calculateReorderQuantity(InventoryItem item) {
        // Calculate based on historical demand and lead time
        int suggestedQuantity = Math.max(
            item.getReorderQuantity(),
            (int) (demandForecastService.getAverageDailyDemand(item.getProductId()) * 
                   supplierService.getLeadTimeDays(item.getProductId()) * 1.5)
        );
        
        return ReorderRequest.builder()
            .productId(item.getProductId())
            .warehouseId(item.getWarehouseId())
            .quantity(suggestedQuantity)
            .priority(available <= item.getReorderPoint() / 2 ? Priority.HIGH : Priority.NORMAL)
            .build();
    }
}
```

================================================================================
## MODULE 4: Payment Processing Gateway
================================================================================

```java
package com.example.payment.service;

import org.springframework.stereotype.Service;
import org.springframework.retry.annotation.Retryable;
import org.springframework.retry.annotation.Backoff;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.math.BigDecimal;
import java.util.UUID;

@Service
@Slf4j
@RequiredArgsConstructor
public class PaymentGatewayService {

    private final StripeClient stripeClient;
    private final PayPalClient payPalClient;
    private final PaymentRepository paymentRepository;
    private final FraudDetectionService fraudDetectionService;
    private final CurrencyConversionService currencyService;
    private final PaymentEventPublisher eventPublisher;

    @Retryable(
        value = {PaymentGatewayException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public PaymentResult processPayment(PaymentRequest request) {
        log.info("Processing payment of {} {} for order {}", 
            request.getAmount(), request.getCurrency(), request.getOrderId());
        
        // Fraud check
        FraudCheckResult fraudResult = fraudDetectionService.checkTransaction(request);
        if (fraudResult.isBlocked()) {
            log.warn("Payment blocked by fraud detection: {}", fraudResult.getReason());
            return PaymentResult.failed(fraudResult.getReason());
        }
        
        // Create payment record
        Payment payment = Payment.builder()
            .id(UUID.randomUUID().toString())
            .orderId(request.getOrderId())
            .amount(request.getAmount())
            .currency(request.getCurrency())
            .paymentMethodId(request.getPaymentMethodId())
            .status(PaymentStatus.PROCESSING)
            .createdAt(Instant.now())
            .build();
        
        paymentRepository.save(payment);
        
        try {
            PaymentResult result = processWithGateway(request, payment);
            
            if (result.isSuccessful()) {
                payment.setStatus(PaymentStatus.COMPLETED);
                payment.setGatewayTransactionId(result.getTransactionId());
                payment.setCompletedAt(Instant.now());
                
                eventPublisher.publishPaymentCompleted(payment);
            } else {
                payment.setStatus(PaymentStatus.FAILED);
                payment.setErrorMessage(result.getErrorMessage());
                
                eventPublisher.publishPaymentFailed(payment);
            }
            
            paymentRepository.save(payment);
            return result;
            
        } catch (Exception e) {
            log.error("Payment processing error for order {}: {}", request.getOrderId(), e.getMessage());
            
            payment.setStatus(PaymentStatus.ERROR);
            payment.setErrorMessage(e.getMessage());
            paymentRepository.save(payment);
            
            throw new PaymentProcessingException("Payment processing failed", e);
        }
    }

    @Retryable(
        value = {RefundException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 2000, multiplier = 2)
    )
    public RefundResult refund(String paymentId, BigDecimal amount, String reason) {
        Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow(() -> new PaymentNotFoundException(paymentId));
        
        if (payment.getStatus() != PaymentStatus.COMPLETED) {
            throw new RefundException("Cannot refund payment in status: " + payment.getStatus());
        }
        
        BigDecimal refundedAmount = payment.getRefunds().stream()
            .map(Refund::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal maxRefundable = payment.getAmount().subtract(refundedAmount);
        if (amount.compareTo(maxRefundable) > 0) {
            throw new RefundException("Refund amount exceeds available: " + maxRefundable);
        }
        
        log.info("Processing refund of {} for payment {}", amount, paymentId);
        
        RefundResult result = switch (payment.getGateway()) {
            case STRIPE -> stripeClient.refund(payment.getGatewayTransactionId(), amount);
            case PAYPAL -> payPalClient.refund(payment.getGatewayTransactionId(), amount);
            default -> throw new UnsupportedGatewayException(payment.getGateway());
        };
        
        if (result.isSuccessful()) {
            Refund refund = Refund.builder()
                .id(UUID.randomUUID().toString())
                .paymentId(paymentId)
                .amount(amount)
                .reason(reason)
                .gatewayRefundId(result.getRefundId())
                .createdAt(Instant.now())
                .build();
            
            payment.getRefunds().add(refund);
            
            if (payment.getAmount().equals(refundedAmount.add(amount))) {
                payment.setStatus(PaymentStatus.FULLY_REFUNDED);
            } else {
                payment.setStatus(PaymentStatus.PARTIALLY_REFUNDED);
            }
            
            paymentRepository.save(payment);
            eventPublisher.publishRefundCompleted(refund);
        }
        
        return result;
    }

    public PaymentStatus getPaymentStatus(String paymentId) {
        return paymentRepository.findById(paymentId)
            .map(Payment::getStatus)
            .orElseThrow(() -> new PaymentNotFoundException(paymentId));
    }

    public List<Payment> getPaymentHistory(String orderId) {
        return paymentRepository.findByOrderId(orderId);
    }

    private PaymentResult processWithGateway(PaymentRequest request, Payment payment) {
        PaymentMethod method = paymentMethodRepository.findById(request.getPaymentMethodId())
            .orElseThrow(() -> new PaymentMethodNotFoundException(request.getPaymentMethodId()));
        
        // Currency conversion if needed
        BigDecimal processAmount = request.getAmount();
        String processCurrency = request.getCurrency();
        
        if (!method.getSupportedCurrencies().contains(request.getCurrency())) {
            CurrencyConversion conversion = currencyService.convert(
                request.getAmount(), 
                request.getCurrency(), 
                method.getDefaultCurrency()
            );
            processAmount = conversion.getConvertedAmount();
            processCurrency = conversion.getTargetCurrency();
            payment.setConversionRate(conversion.getRate());
        }
        
        PaymentGateway gateway = method.getGateway();
        payment.setGateway(gateway);
        
        return switch (gateway) {
            case STRIPE -> stripeClient.charge(
                method.getGatewayToken(),
                processAmount,
                processCurrency,
                payment.getId()
            );
            case PAYPAL -> payPalClient.charge(
                method.getGatewayToken(),
                processAmount,
                processCurrency,
                payment.getId()
            );
            default -> throw new UnsupportedGatewayException(gateway);
        };
    }

    @Scheduled(fixedRate = 60000)
    public void reconcilePendingPayments() {
        List<Payment> pendingPayments = paymentRepository.findByStatusAndCreatedAtBefore(
            PaymentStatus.PROCESSING,
            Instant.now().minus(Duration.ofMinutes(15))
        );
        
        for (Payment payment : pendingPayments) {
            try {
                PaymentStatus gatewayStatus = queryGatewayStatus(payment);
                
                if (gatewayStatus != payment.getStatus()) {
                    log.info("Reconciling payment {}: {} -> {}", 
                        payment.getId(), payment.getStatus(), gatewayStatus);
                    
                    payment.setStatus(gatewayStatus);
                    paymentRepository.save(payment);
                    
                    if (gatewayStatus == PaymentStatus.COMPLETED) {
                        eventPublisher.publishPaymentCompleted(payment);
                    } else if (gatewayStatus == PaymentStatus.FAILED) {
                        eventPublisher.publishPaymentFailed(payment);
                    }
                }
            } catch (Exception e) {
                log.error("Error reconciling payment {}: {}", payment.getId(), e.getMessage());
            }
        }
    }

    private PaymentStatus queryGatewayStatus(Payment payment) {
        return switch (payment.getGateway()) {
            case STRIPE -> stripeClient.getStatus(payment.getGatewayTransactionId());
            case PAYPAL -> payPalClient.getStatus(payment.getGatewayTransactionId());
            default -> payment.getStatus();
        };
    }
}
```

================================================================================
## MODULE 5: Notification Service
================================================================================

```java
package com.example.notification.service;

import org.springframework.stereotype.Service;
import org.springframework.scheduling.annotation.Async;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class NotificationService {

    private final EmailService emailService;
    private final SmsService smsService;
    private final PushNotificationService pushService;
    private final NotificationTemplateService templateService;
    private final UserPreferenceService preferenceService;
    private final NotificationRepository notificationRepository;

    @Async
    public void sendOrderConfirmation(Order order) {
        User user = userService.getUser(order.getCustomerId());
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        
        NotificationTemplate template = templateService.getTemplate("ORDER_CONFIRMATION");
        Map<String, Object> variables = buildOrderVariables(order);
        
        List<NotificationChannel> channels = determineChannels(prefs, NotificationType.ORDER_UPDATE);
        
        for (NotificationChannel channel : channels) {
            try {
                sendViaChannel(channel, user, template, variables);
                
                logNotification(user.getId(), NotificationType.ORDER_UPDATE, channel, "SUCCESS");
            } catch (Exception e) {
                log.error("Failed to send {} notification to user {}: {}", 
                    channel, user.getId(), e.getMessage());
                logNotification(user.getId(), NotificationType.ORDER_UPDATE, channel, "FAILED");
            }
        }
    }

    @Async
    public void sendOrderCancellation(Order order) {
        User user = userService.getUser(order.getCustomerId());
        NotificationTemplate template = templateService.getTemplate("ORDER_CANCELLED");
        
        Map<String, Object> variables = Map.of(
            "orderId", order.getId(),
            "reason", order.getCancellationReason(),
            "refundAmount", order.getTotal()
        );
        
        sendToAllChannels(user, template, variables, NotificationType.ORDER_UPDATE);
    }

    @Async
    public void sendShippingUpdate(Shipment shipment) {
        Order order = orderService.getOrder(shipment.getOrderId());
        User user = userService.getUser(order.getCustomerId());
        
        String templateName = switch (shipment.getStatus()) {
            case SHIPPED -> "ORDER_SHIPPED";
            case OUT_FOR_DELIVERY -> "ORDER_OUT_FOR_DELIVERY";
            case DELIVERED -> "ORDER_DELIVERED";
            default -> null;
        };
        
        if (templateName == null) return;
        
        NotificationTemplate template = templateService.getTemplate(templateName);
        Map<String, Object> variables = Map.of(
            "orderId", order.getId(),
            "trackingNumber", shipment.getTrackingNumber(),
            "carrier", shipment.getCarrier(),
            "estimatedDelivery", shipment.getEstimatedDeliveryDate()
        );
        
        sendToAllChannels(user, template, variables, NotificationType.SHIPPING_UPDATE);
    }

    @Async
    public void sendLowStockAlert(InventoryItem item) {
        List<User> admins = userService.getUsersByRole(Role.INVENTORY_MANAGER);
        NotificationTemplate template = templateService.getTemplate("LOW_STOCK_ALERT");
        
        Map<String, Object> variables = Map.of(
            "productId", item.getProductId(),
            "productName", productService.getProduct(item.getProductId()).getName(),
            "currentStock", item.getQuantityOnHand(),
            "reorderPoint", item.getReorderPoint(),
            "warehouseId", item.getWarehouseId()
        );
        
        for (User admin : admins) {
            sendViaChannel(NotificationChannel.EMAIL, admin, template, variables);
        }
    }

    @Async
    public void sendPasswordResetEmail(User user, String resetToken) {
        NotificationTemplate template = templateService.getTemplate("PASSWORD_RESET");
        
        Map<String, Object> variables = Map.of(
            "userName", user.getName(),
            "resetLink", buildResetLink(resetToken),
            "expiresIn", "24 hours"
        );
        
        emailService.send(
            user.getEmail(),
            template.getSubject(),
            template.renderBody(variables)
        );
        
        logNotification(user.getId(), NotificationType.SECURITY, NotificationChannel.EMAIL, "SUCCESS");
    }

    @Async
    public void sendTwoFactorCode(User user, String code) {
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        
        String message = String.format("Your verification code is: %s. Valid for 10 minutes.", code);
        
        if (prefs.getTwoFactorChannel() == NotificationChannel.SMS) {
            smsService.send(user.getPhoneNumber(), message);
        } else {
            emailService.send(user.getEmail(), "Verification Code", message);
        }
    }

    @Scheduled(cron = "0 0 9 * * *")
    public void sendDailyDigest() {
        List<User> users = userService.getUsersWithDigestEnabled();
        
        for (User user : users) {
            try {
                DigestContent content = buildDigestContent(user);
                
                if (content.hasItems()) {
                    NotificationTemplate template = templateService.getTemplate("DAILY_DIGEST");
                    emailService.send(
                        user.getEmail(),
                        template.getSubject(),
                        template.renderBody(Map.of("digest", content))
                    );
                }
            } catch (Exception e) {
                log.error("Failed to send digest to user {}: {}", user.getId(), e.getMessage());
            }
        }
    }

    private void sendViaChannel(NotificationChannel channel, User user, 
                                 NotificationTemplate template, Map<String, Object> variables) {
        switch (channel) {
            case EMAIL -> emailService.send(
                user.getEmail(),
                template.getSubject(),
                template.renderBody(variables)
            );
            case SMS -> smsService.send(
                user.getPhoneNumber(),
                template.renderSmsBody(variables)
            );
            case PUSH -> pushService.send(
                user.getDeviceTokens(),
                template.getTitle(),
                template.renderPushBody(variables)
            );
        }
    }

    private void sendToAllChannels(User user, NotificationTemplate template, 
                                    Map<String, Object> variables, NotificationType type) {
        NotificationPreferences prefs = preferenceService.getPreferences(user.getId());
        List<NotificationChannel> channels = determineChannels(prefs, type);
        
        for (NotificationChannel channel : channels) {
            try {
                sendViaChannel(channel, user, template, variables);
                logNotification(user.getId(), type, channel, "SUCCESS");
            } catch (Exception e) {
                log.error("Notification failed: {} via {} - {}", type, channel, e.getMessage());
                logNotification(user.getId(), type, channel, "FAILED");
            }
        }
    }

    private List<NotificationChannel> determineChannels(NotificationPreferences prefs, 
                                                         NotificationType type) {
        return prefs.getChannelPreferences().entrySet().stream()
            .filter(e -> e.getValue().contains(type))
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }

    private void logNotification(Long userId, NotificationType type, 
                                  NotificationChannel channel, String status) {
        NotificationLog log = NotificationLog.builder()
            .userId(userId)
            .type(type)
            .channel(channel)
            .status(status)
            .sentAt(Instant.now())
            .build();
        
        notificationRepository.save(log);
    }

    private Map<String, Object> buildOrderVariables(Order order) {
        return Map.of(
            "orderId", order.getId(),
            "items", order.getItems(),
            "subtotal", order.getSubtotal(),
            "tax", order.getTax(),
            "shipping", order.getShippingCost(),
            "total", order.getTotal(),
            "shippingAddress", order.getShippingAddress(),
            "estimatedDelivery", calculateEstimatedDelivery(order)
        );
    }
}
```

================================================================================
## MODULE 6: Reporting and Analytics
================================================================================

```java
package com.example.analytics.service;

import org.springframework.stereotype.Service;
import org.springframework.cache.annotation.Cacheable;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class AnalyticsService {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;
    private final InventoryRepository inventoryRepository;
    private final RevenueCalculator revenueCalculator;

    @Cacheable(value = "salesReport", key = "#startDate + '-' + #endDate")
    public SalesReport generateSalesReport(LocalDate startDate, LocalDate endDate) {
        log.info("Generating sales report for {} to {}", startDate, endDate);
        
        List<Order> orders = orderRepository.findByCreatedAtBetween(
            startDate.atStartOfDay().toInstant(ZoneOffset.UTC),
            endDate.plusDays(1).atStartOfDay().toInstant(ZoneOffset.UTC)
        );
        
        // Filter completed orders only
        List<Order> completedOrders = orders.stream()
            .filter(o -> o.getStatus() == OrderStatus.COMPLETED || 
                        o.getStatus() == OrderStatus.DELIVERED)
            .collect(Collectors.toList());
        
        // Calculate metrics
        BigDecimal totalRevenue = completedOrders.stream()
            .map(Order::getTotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal totalTax = completedOrders.stream()
            .map(Order::getTax)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal averageOrderValue = completedOrders.isEmpty() 
            ? BigDecimal.ZERO 
            : totalRevenue.divide(BigDecimal.valueOf(completedOrders.size()), RoundingMode.HALF_UP);
        
        // Daily breakdown
        Map<LocalDate, DailySales> dailyBreakdown = completedOrders.stream()
            .collect(Collectors.groupingBy(
                o -> o.getCreatedAt().atZone(ZoneOffset.UTC).toLocalDate(),
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    this::calculateDailySales
                )
            ));
        
        // Top products
        List<ProductSales> topProducts = calculateTopProducts(completedOrders, 10);
        
        // Category breakdown
        Map<String, CategorySales> categoryBreakdown = calculateCategoryBreakdown(completedOrders);
        
        return SalesReport.builder()
            .startDate(startDate)
            .endDate(endDate)
            .totalOrders(completedOrders.size())
            .totalRevenue(totalRevenue)
            .totalTax(totalTax)
            .averageOrderValue(averageOrderValue)
            .dailyBreakdown(dailyBreakdown)
            .topProducts(topProducts)
            .categoryBreakdown(categoryBreakdown)
            .generatedAt(Instant.now())
            .build();
    }

    @Cacheable(value = "customerAnalytics", key = "#customerId")
    public CustomerAnalytics getCustomerAnalytics(Long customerId) {
        User customer = userRepository.findById(customerId)
            .orElseThrow(() -> new UserNotFoundException(customerId));
        
        List<Order> orders = orderRepository.findByCustomerId(customerId);
        
        BigDecimal totalSpent = orders.stream()
            .filter(o -> o.getStatus() == OrderStatus.COMPLETED)
            .map(Order::getTotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal averageOrderValue = orders.isEmpty() 
            ? BigDecimal.ZERO 
            : totalSpent.divide(BigDecimal.valueOf(orders.size()), RoundingMode.HALF_UP);
        
        // Purchase frequency
        long daysSinceFirstOrder = orders.isEmpty() ? 0 :
            ChronoUnit.DAYS.between(
                orders.stream().map(Order::getCreatedAt).min(Instant::compareTo).get()
                    .atZone(ZoneOffset.UTC).toLocalDate(),
                LocalDate.now()
            );
        
        double ordersPerMonth = daysSinceFirstOrder > 0 
            ? (double) orders.size() / (daysSinceFirstOrder / 30.0) 
            : 0;
        
        // Favorite categories
        Map<String, Long> categoryPreferences = orders.stream()
            .flatMap(o -> o.getItems().stream())
            .collect(Collectors.groupingBy(
                item -> productRepository.findById(item.getProductId())
                    .map(Product::getCategory)
                    .orElse("Unknown"),
                Collectors.counting()
            ));
        
        // Customer segment
        CustomerSegment segment = determineCustomerSegment(totalSpent, orders.size(), ordersPerMonth);
        
        return CustomerAnalytics.builder()
            .customerId(customerId)
            .customerName(customer.getName())
            .memberSince(customer.getCreatedAt())
            .totalOrders(orders.size())
            .totalSpent(totalSpent)
            .averageOrderValue(averageOrderValue)
            .ordersPerMonth(ordersPerMonth)
            .categoryPreferences(categoryPreferences)
            .segment(segment)
            .lastOrderDate(orders.stream()
                .map(Order::getCreatedAt)
                .max(Instant::compareTo)
                .orElse(null))
            .build();
    }

    public InventoryReport generateInventoryReport() {
        List<InventoryItem> allItems = inventoryRepository.findAll();
        
        // Group by product
        Map<Long, List<InventoryItem>> byProduct = allItems.stream()
            .collect(Collectors.groupingBy(InventoryItem::getProductId));
        
        List<ProductInventoryStatus> productStatuses = byProduct.entrySet().stream()
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                List<InventoryItem> items = entry.getValue();
                
                int totalOnHand = items.stream().mapToInt(InventoryItem::getQuantityOnHand).sum();
                int totalReserved = items.stream().mapToInt(InventoryItem::getQuantityReserved).sum();
                
                InventoryHealthStatus health = determineHealthStatus(items);
                
                return ProductInventoryStatus.builder()
                    .productId(entry.getKey())
                    .productName(product != null ? product.getName() : "Unknown")
                    .totalOnHand(totalOnHand)
                    .totalReserved(totalReserved)
                    .totalAvailable(totalOnHand - totalReserved)
                    .health(health)
                    .warehouseBreakdown(items.stream()
                        .collect(Collectors.toMap(
                            InventoryItem::getWarehouseId,
                            i -> i.getQuantityOnHand() - i.getQuantityReserved()
                        )))
                    .build();
            })
            .sorted(Comparator.comparing(ProductInventoryStatus::getHealth))
            .collect(Collectors.toList());
        
        // Summary metrics
        long criticalItems = productStatuses.stream()
            .filter(p -> p.getHealth() == InventoryHealthStatus.CRITICAL)
            .count();
        
        long lowStockItems = productStatuses.stream()
            .filter(p -> p.getHealth() == InventoryHealthStatus.LOW)
            .count();
        
        BigDecimal totalInventoryValue = productStatuses.stream()
            .map(p -> {
                Product product = productRepository.findById(p.getProductId()).orElse(null);
                return product != null 
                    ? product.getCost().multiply(BigDecimal.valueOf(p.getTotalOnHand()))
                    : BigDecimal.ZERO;
            })
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        return InventoryReport.builder()
            .generatedAt(Instant.now())
            .totalProducts(productStatuses.size())
            .criticalStockItems(criticalItems)
            .lowStockItems(lowStockItems)
            .healthyStockItems(productStatuses.size() - criticalItems - lowStockItems)
            .totalInventoryValue(totalInventoryValue)
            .productStatuses(productStatuses)
            .build();
    }

    @Scheduled(cron = "0 0 1 * * *")
    public void generateDailyMetrics() {
        LocalDate yesterday = LocalDate.now().minusDays(1);
        
        DailyMetrics metrics = DailyMetrics.builder()
            .date(yesterday)
            .salesReport(generateSalesReport(yesterday, yesterday))
            .newCustomers(userRepository.countByCreatedAtBetween(
                yesterday.atStartOfDay().toInstant(ZoneOffset.UTC),
                yesterday.plusDays(1).atStartOfDay().toInstant(ZoneOffset.UTC)
            ))
            .activeUsers(sessionRepository.countDistinctUsersByDate(yesterday))
            .conversionRate(calculateConversionRate(yesterday))
            .build();
        
        metricsRepository.save(metrics);
        
        log.info("Daily metrics generated for {}: {} orders, {} revenue", 
            yesterday, metrics.getSalesReport().getTotalOrders(), 
            metrics.getSalesReport().getTotalRevenue());
    }

    private DailySales calculateDailySales(List<Order> orders) {
        return DailySales.builder()
            .orderCount(orders.size())
            .revenue(orders.stream()
                .map(Order::getTotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add))
            .build();
    }

    private List<ProductSales> calculateTopProducts(List<Order> orders, int limit) {
        Map<Long, ProductSalesAccumulator> accumulator = new HashMap<>();
        
        for (Order order : orders) {
            for (OrderItem item : order.getItems()) {
                accumulator.computeIfAbsent(item.getProductId(), 
                    k -> new ProductSalesAccumulator(item.getProductId(), item.getProductName()))
                    .add(item.getQuantity(), item.getTotalPrice());
            }
        }
        
        return accumulator.values().stream()
            .sorted(Comparator.comparing(ProductSalesAccumulator::getRevenue).reversed())
            .limit(limit)
            .map(ProductSalesAccumulator::toProductSales)
            .collect(Collectors.toList());
    }

    private Map<String, CategorySales> calculateCategoryBreakdown(List<Order> orders) {
        Map<String, CategorySalesAccumulator> accumulator = new HashMap<>();
        
        for (Order order : orders) {
            for (OrderItem item : order.getItems()) {
                String category = productRepository.findById(item.getProductId())
                    .map(Product::getCategory)
                    .orElse("Uncategorized");
                
                accumulator.computeIfAbsent(category, CategorySalesAccumulator::new)
                    .add(item.getQuantity(), item.getTotalPrice());
            }
        }
        
        return accumulator.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().toCategorySales()
            ));
    }

    private CustomerSegment determineCustomerSegment(BigDecimal totalSpent, int orderCount, 
                                                      double ordersPerMonth) {
        if (totalSpent.compareTo(BigDecimal.valueOf(10000)) > 0 && ordersPerMonth > 2) {
            return CustomerSegment.VIP;
        } else if (totalSpent.compareTo(BigDecimal.valueOf(5000)) > 0 && ordersPerMonth > 1) {
            return CustomerSegment.LOYAL;
        } else if (orderCount > 5) {
            return CustomerSegment.REGULAR;
        } else if (orderCount > 0) {
            return CustomerSegment.OCCASIONAL;
        } else {
            return CustomerSegment.NEW;
        }
    }

    private InventoryHealthStatus determineHealthStatus(List<InventoryItem> items) {
        int totalAvailable = items.stream()
            .mapToInt(i -> i.getQuantityOnHand() - i.getQuantityReserved())
            .sum();
        
        int avgReorderPoint = (int) items.stream()
            .mapToInt(InventoryItem::getReorderPoint)
            .average()
            .orElse(0);
        
        if (totalAvailable <= 0) {
            return InventoryHealthStatus.OUT_OF_STOCK;
        } else if (totalAvailable <= avgReorderPoint / 2) {
            return InventoryHealthStatus.CRITICAL;
        } else if (totalAvailable <= avgReorderPoint) {
            return InventoryHealthStatus.LOW;
        } else {
            return InventoryHealthStatus.HEALTHY;
        }
    }
}
```

================================================================================
## MODULE 7: Search and Recommendation Engine
================================================================================

```java
package com.example.search.service;

import org.springframework.stereotype.Service;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class SearchAndRecommendationService {

    private final RestHighLevelClient elasticsearchClient;
    private final ProductRepository productRepository;
    private final UserBehaviorRepository behaviorRepository;
    private final SimilarityCalculator similarityCalculator;
    private final MLRecommendationClient mlClient;

    public SearchResults search(SearchRequest request) {
        log.info("Searching for: {} with filters: {}", request.getQuery(), request.getFilters());
        
        SearchSourceBuilder searchBuilder = new SearchSourceBuilder();
        
        // Build query
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // Full-text search on name, description, tags
        if (StringUtils.isNotBlank(request.getQuery())) {
            boolQuery.must(QueryBuilders.multiMatchQuery(request.getQuery())
                .field("name", 3.0f)
                .field("description", 1.0f)
                .field("tags", 2.0f)
                .field("category", 1.5f)
                .fuzziness(Fuzziness.AUTO)
                .prefixLength(2));
        }
        
        // Apply filters
        if (request.getFilters() != null) {
            applyFilters(boolQuery, request.getFilters());
        }
        
        searchBuilder.query(boolQuery);
        
        // Sorting
        if (request.getSortBy() != null) {
            searchBuilder.sort(request.getSortBy(), 
                request.getSortOrder() == SortOrder.DESC ? SortOrder.DESC : SortOrder.ASC);
        } else {
            searchBuilder.sort("_score", SortOrder.DESC);
        }
        
        // Pagination
        searchBuilder.from(request.getPage() * request.getSize());
        searchBuilder.size(request.getSize());
        
        // Execute search
        SearchResponse response = elasticsearchClient.search(
            new SearchRequest("products").source(searchBuilder),
            RequestOptions.DEFAULT
        );
        
        // Map results
        List<ProductSearchResult> results = Arrays.stream(response.getHits().getHits())
            .map(hit -> {
                Map<String, Object> source = hit.getSourceAsMap();
                return ProductSearchResult.builder()
                    .productId(Long.parseLong(hit.getId()))
                    .name((String) source.get("name"))
                    .description((String) source.get("description"))
                    .price(new BigDecimal(source.get("price").toString()))
                    .category((String) source.get("category"))
                    .imageUrl((String) source.get("imageUrl"))
                    .rating((Double) source.get("rating"))
                    .score(hit.getScore())
                    .build();
            })
            .collect(Collectors.toList());
        
        // Get facets/aggregations
        Map<String, List<FacetValue>> facets = extractFacets(response.getAggregations());
        
        // Log search for analytics
        logSearchEvent(request, response.getHits().getTotalHits().value);
        
        return SearchResults.builder()
            .query(request.getQuery())
            .results(results)
            .totalHits(response.getHits().getTotalHits().value)
            .page(request.getPage())
            .size(request.getSize())
            .facets(facets)
            .searchTime(response.getTook().getMillis())
            .build();
    }

    public List<ProductRecommendation> getPersonalizedRecommendations(Long userId, int limit) {
        log.debug("Getting personalized recommendations for user: {}", userId);
        
        // Get user behavior history
        UserBehaviorProfile profile = buildUserProfile(userId);
        
        // Try ML-based recommendations first
        try {
            List<Long> mlRecommendations = mlClient.getRecommendations(userId, limit * 2);
            
            if (!mlRecommendations.isEmpty()) {
                return mlRecommendations.stream()
                    .map(productId -> productRepository.findById(productId).orElse(null))
                    .filter(Objects::nonNull)
                    .filter(p -> !profile.getPurchasedProductIds().contains(p.getId()))
                    .limit(limit)
                    .map(p -> ProductRecommendation.builder()
                        .product(p)
                        .reason("Based on your shopping history")
                        .score(0.9)
                        .build())
                    .collect(Collectors.toList());
            }
        } catch (Exception e) {
            log.warn("ML recommendation service unavailable, falling back to rule-based", e);
        }
        
        // Fallback: Rule-based recommendations
        return getRuleBasedRecommendations(profile, limit);
    }

    public List<ProductRecommendation> getSimilarProducts(Long productId, int limit) {
        Product baseProduct = productRepository.findById(productId)
            .orElseThrow(() -> new ProductNotFoundException(productId));
        
        // Get products in same category
        List<Product> categoryProducts = productRepository.findByCategory(baseProduct.getCategory());
        
        // Calculate similarity scores
        return categoryProducts.stream()
            .filter(p -> !p.getId().equals(productId))
            .map(p -> {
                double similarity = similarityCalculator.calculate(baseProduct, p);
                return ProductRecommendation.builder()
                    .product(p)
                    .reason("Similar to " + baseProduct.getName())
                    .score(similarity)
                    .build();
            })
            .filter(r -> r.getScore() > 0.3)
            .sorted(Comparator.comparing(ProductRecommendation::getScore).reversed())
            .limit(limit)
            .collect(Collectors.toList());
    }

    public List<ProductRecommendation> getFrequentlyBoughtTogether(Long productId, int limit) {
        // Find orders containing this product
        List<Order> ordersWithProduct = orderRepository.findByItemsProductId(productId);
        
        // Count co-occurrence of other products
        Map<Long, Long> coOccurrence = ordersWithProduct.stream()
            .flatMap(o -> o.getItems().stream())
            .map(OrderItem::getProductId)
            .filter(id -> !id.equals(productId))
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        
        // Get top co-occurring products
        return coOccurrence.entrySet().stream()
            .sorted(Map.Entry.<Long, Long>comparingByValue().reversed())
            .limit(limit)
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                if (product == null) return null;
                
                double score = (double) entry.getValue() / ordersWithProduct.size();
                return ProductRecommendation.builder()
                    .product(product)
                    .reason("Frequently bought together")
                    .score(score)
                    .build();
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }

    public List<ProductRecommendation> getTrendingProducts(int limit) {
        LocalDate weekAgo = LocalDate.now().minusDays(7);
        
        // Get recent orders
        List<Order> recentOrders = orderRepository.findByCreatedAtAfter(
            weekAgo.atStartOfDay().toInstant(ZoneOffset.UTC)
        );
        
        // Count product sales with recency weighting
        Map<Long, Double> trendingScores = new HashMap<>();
        
        for (Order order : recentOrders) {
            long daysAgo = ChronoUnit.DAYS.between(
                order.getCreatedAt().atZone(ZoneOffset.UTC).toLocalDate(),
                LocalDate.now()
            );
            double recencyWeight = 1.0 / (1.0 + daysAgo * 0.1);
            
            for (OrderItem item : order.getItems()) {
                trendingScores.merge(item.getProductId(), 
                    item.getQuantity() * recencyWeight, 
                    Double::sum);
            }
        }
        
        // Normalize and return top trending
        double maxScore = trendingScores.values().stream()
            .max(Double::compareTo)
            .orElse(1.0);
        
        return trendingScores.entrySet().stream()
            .sorted(Map.Entry.<Long, Double>comparingByValue().reversed())
            .limit(limit)
            .map(entry -> {
                Product product = productRepository.findById(entry.getKey()).orElse(null);
                if (product == null) return null;
                
                return ProductRecommendation.builder()
                    .product(product)
                    .reason("Trending this week")
                    .score(entry.getValue() / maxScore)
                    .build();
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }

    @Async
    public void trackUserBehavior(Long userId, BehaviorEvent event) {
        UserBehavior behavior = UserBehavior.builder()
            .userId(userId)
            .eventType(event.getType())
            .productId(event.getProductId())
            .searchQuery(event.getSearchQuery())
            .timestamp(Instant.now())
            .sessionId(event.getSessionId())
            .metadata(event.getMetadata())
            .build();
        
        behaviorRepository.save(behavior);
        
        // Update real-time recommendations cache if significant event
        if (event.getType() == BehaviorType.PURCHASE || 
            event.getType() == BehaviorType.ADD_TO_CART) {
            recommendationCache.invalidate(userId);
        }
    }

    private void applyFilters(BoolQueryBuilder boolQuery, SearchFilters filters) {
        if (filters.getCategories() != null && !filters.getCategories().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("category", filters.getCategories()));
        }
        
        if (filters.getMinPrice() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("price").gte(filters.getMinPrice()));
        }
        
        if (filters.getMaxPrice() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("price").lte(filters.getMaxPrice()));
        }
        
        if (filters.getMinRating() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("rating").gte(filters.getMinRating()));
        }
        
        if (filters.getInStock() != null && filters.getInStock()) {
            boolQuery.filter(QueryBuilders.termQuery("inStock", true));
        }
        
        if (filters.getBrands() != null && !filters.getBrands().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("brand", filters.getBrands()));
        }
        
        if (filters.getTags() != null && !filters.getTags().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("tags", filters.getTags()));
        }
    }

    private UserBehaviorProfile buildUserProfile(Long userId) {
        List<UserBehavior> behaviors = behaviorRepository.findByUserIdOrderByTimestampDesc(
            userId, PageRequest.of(0, 1000)
        );
        
        Set<Long> purchasedProducts = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.PURCHASE)
            .map(UserBehavior::getProductId)
            .collect(Collectors.toSet());
        
        Set<Long> viewedProducts = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.VIEW)
            .map(UserBehavior::getProductId)
            .collect(Collectors.toSet());
        
        Map<String, Long> categoryInterests = behaviors.stream()
            .filter(b -> b.getProductId() != null)
            .map(b -> productRepository.findById(b.getProductId())
                .map(Product::getCategory)
                .orElse(null))
            .filter(Objects::nonNull)
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        
        List<String> recentSearches = behaviors.stream()
            .filter(b -> b.getEventType() == BehaviorType.SEARCH)
            .map(UserBehavior::getSearchQuery)
            .filter(Objects::nonNull)
            .limit(20)
            .collect(Collectors.toList());
        
        return UserBehaviorProfile.builder()
            .userId(userId)
            .purchasedProductIds(purchasedProducts)
            .viewedProductIds(viewedProducts)
            .categoryInterests(categoryInterests)
            .recentSearches(recentSearches)
            .build();
    }

    private List<ProductRecommendation> getRuleBasedRecommendations(UserBehaviorProfile profile, 
                                                                      int limit) {
        List<ProductRecommendation> recommendations = new ArrayList<>();
        
        // 1. Products from favorite categories
        String topCategory = profile.getCategoryInterests().entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
        
        if (topCategory != null) {
            productRepository.findByCategoryAndIdNotIn(topCategory, profile.getPurchasedProductIds())
                .stream()
                .limit(limit / 2)
                .forEach(p -> recommendations.add(ProductRecommendation.builder()
                    .product(p)
                    .reason("Based on your interest in " + topCategory)
                    .score(0.7)
                    .build()));
        }
        
        // 2. Highly rated products user hasn't purchased
        productRepository.findTopRatedNotPurchased(profile.getPurchasedProductIds(), limit / 2)
            .forEach(p -> recommendations.add(ProductRecommendation.builder()
                .product(p)
                .reason("Top rated product")
                .score(0.6)
                .build()));
        
        return recommendations.stream()
            .distinct()
            .limit(limit)
            .collect(Collectors.toList());
    }
}
```

================================================================================
## END OF FILE - REPEAT SECTION FOR SIZE
================================================================================
